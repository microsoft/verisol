import sys
from os import makedirs
from os.path import join, dirname, realpath
from shutil import copyfile

from antlr4 import *

from CelestialLexer import CelestialLexer
from CelestialParser import CelestialParser
from CelestialParserListener import CelestialParserListener


class SolidityCodegen:

    def __init__(self, outputDir, verificationMode):
        self.output = None
        self.outputDir = outputDir
        self.verificationMode = verificationMode #Added for Verisol
        self.invariants_collected = "" #Added for Verisol
        self.fieldPrefix = ""
        self.indentationLevel = 0
        self.arithLibFlag = False
        self.callLibFlag = False
        self.contracts = []
        self.structs = []
        self.enumTypes = []

    def isBasicType(self, varType):
        return (varType in ["int", "uint", "address", "bool"])

    def writeLibrary(self):
        libName = join(self.outputDir, "Safe_Arith.sol")
        libFile = open(libName, "w")
        libFile.write("// SPDX-License-Identifier: MIT")
        libFile.write("\n/* Code generated by compiler */")
        libFile.write("\nlibrary Safe_Arith {")
        libFile.write("\n")
        libFile.write("\n    function safe_add (uint a, uint b) public pure returns (uint) {")
        libFile.write("\n        if (a > a + b) revert (\"<Safe_Arith.add> Overflow Error\");")
        libFile.write("\n        else return (a + b);")
        libFile.write("\n    }")
        libFile.write("\n    ")
        libFile.write("\n    function safe_sub (uint a, uint b) public pure returns (uint) {")
        libFile.write("\n        if (a < b) revert (\"<Safe_Arith.sub> Underflow Error\");")
        libFile.write("\n        else return (a - b);")
        libFile.write("\n    }")
        libFile.write("\n    ")
        libFile.write("\n    function safe_mul (uint a, uint b) public pure returns (uint) {")
        libFile.write("\n        if (b == 0) return 0;")
        libFile.write("\n        if (a != (a * b)/b) revert (\"<Safe_Arith.mul> Overflow Error\");")
        libFile.write("\n        else return (a * b);")
        libFile.write("\n    }")
        libFile.write("\n    ")
        libFile.write("\n    function safe_div (uint a, uint b) public pure returns (uint) {")
        libFile.write("\n        if (b == 0) revert (\"<Safe_Arith.div> Division by 0 error\");")
        libFile.write("\n        else return (a / b);")
        libFile.write("\n    }")
        libFile.write("\n}")

        dir_path = dirname(realpath(__file__))
        copyfile(join(dir_path + "/lib/Call.sol"), join(self.outputDir, "Call.sol"))

        if self.verificationMode == "VeriSol":
            copyfile(join(dir_path + "/lib/VeriSolContracts.sol"), join(self.outputDir, "VeriSolContracts.sol"))


    def enterProgram(self):
        filename = join(self.outputDir, "contract.sol")
        makedirs(dirname(filename), exist_ok=True)
        self.output = open(filename, "w")
        self.output.write("// SPDX-License-Identifier: MIT")
        # self.output.write("\n/* Code generated by compiler */")
        # self.writeToSolidity("")
        # self.writeToSolidity("pragma solidity >=0.5.0 <0.7.0;")
        # self.writeToSolidity("")               

        self.writeLibrary()

    def exitProgram(self):
        # if self.arithLibFlag or self.callLibFlag:
        #     filename = join(self.outputDir, "contract.sol")
        #     self.output.close()
        #     self.output = open(filename, "r")
        #     contents = self.output.readlines()
        #     index = contents.index("pragma solidity >=0.5.0 <0.7.0;\n")
        #     library = ""
        #     if self.arithLibFlag:
        #         library = "\nimport {Safe_Arith} from \"./Safe_Arith.sol\";"
        #     if self.callLibFlag:
        #         library += "\nimport \"./Call.sol\";"
        #     contents.insert(index + 1, library)      

        #     appendedSolFile = open(filename, "w")
        #     contents = "".join(contents)
        #     appendedSolFile.write(contents)
        #     appendedSolFile.close()
        self.output.close()

    def writeImportDirective(self, ctx):
        s = ""
        for child in ctx.getChildren():
            s += (child.getText() + " ")
        self.writeToSolidity(s)

    def writePragmaDirective(self, ctx):
        if self.verificationMode == "VeriSol":
            self.writeToSolidity("pragma solidity >=0.5.0 <0.7.0;")
            self.writeToSolidity("\nimport \"./VeriSolContracts.sol\";") 
        else:
            self.writeToSolidity("pragma " + ctx.pragmaName.getText() + ctx.pragmaValue().getText() + ";")
        self.writeToSolidity("")

    def enterContractDecl(self, ctx:CelestialParser.ContractDeclContext):
        contractName = ctx.iden().Iden().getText()
        self.writeToSolidity("")
        self.writeToSolidity("contract " + contractName + " {")
        self.indentationLevel = 1
        if self.verificationMode == "VeriSol":
            self.invariants_collected = ""

    def exitContractDecl(self, ctx:CelestialParser.ContractDeclContext):
        if self.callLibFlag:
            contractName = ctx.iden().Iden().getText()
            filename = join(self.outputDir, "contract.sol")
            self.output.close()
            self.output = open(filename, "r")
            contents = self.output.readlines()
            self.output.close()
            index = contents.index("contract " + contractName + "{")
            contents.insert(index + 1, "\nusing Call for address;")

            self.output = open(filename, "w")
            contents = "".join(contents)
            self.output.write(contents)

        if self.verificationMode == "VeriSol" and not(self.invariants_collected == ""):
            self.writeallInvariants()           #Added for VeriSol
        self.indentationLevel = 0
        self.writeToSolidity("}")

    def writeUsingForDecl(self, ctx:CelestialParser.UsingForDeclContext, symbols):
        s = ""
        for child in ctx.getChildren():
            s += child.getText() + " "
        self.writeToSolidity(s)

    def getSolidityDatatype(self, ctx:CelestialParser.DatatypeContext):
        if ctx.MAP():
            return "mapping (" + self.getSolidityDatatype(ctx.keyType) + " => " + self.getSolidityDatatype(ctx.valueType) + ")"
        elif ctx.arrayType:
            return self.getSolidityDatatype(ctx.arrayType) + "[]"
        elif ctx.INSTMAP():
            if self.verificationMode == "VeriSol": 
                return "mapping (address => bool)"     #Added for Verisol
            else:
                return "mapping (" + ctx.iden().Iden().getText() + " => bool)"
        else:
            return ctx.getText()

    def enterVarDecl(self, ctx:CelestialParser.VarDeclContext, currentScope, symbols):
        varType = self.getSolidityDatatype(ctx.datatype())
        varName = ctx.iden().Iden().getText()
        varString = ""
        if varType in ["string", "bytes"] and currentScope != "global":
            varString = varType + " memory " + varName # string is memory
        elif not self.isBasicType(varType) and varType not in self.contracts and currentScope != "global" and varType not in ["bytes20", "bytes32"]:
            varString = varType + " storage " + varName
        else:
            varString = varType + " " + varName
        
        if ctx.expr():
            varString += " = " + self.getSolidityExpr(ctx.expr(), symbols, currentScope)
        
        varString += ";"
        self.writeToSolidity(varString)

        # Defining an add function for inst_map fields
        if ctx.datatype().getText()[0:8] == "inst_map":
            self.writeToSolidity("")
            if self.verificationMode == "VeriSol":      #Added for VeriSol & making code straightforward
                self.writeToSolidity("function get_from_" + ctx.iden().Iden().getText() + " ( address payable i) private returns (" + ctx.datatype().getText()[9:-1] + ") {")
                self.writeToSolidity("    if (" + ctx.iden().Iden().getText() + "[i]) return "+ ctx.datatype().getText()[9:-1] +"(i);")    
            else:
                self.writeToSolidity("function get_from_" + ctx.iden().Iden().getText() + " (" + ctx.datatype().getText()[9:-1] + " i) private returns (" + ctx.datatype().getText()[9:-1] + ") {")
                self.writeToSolidity("    if (" + ctx.iden().Iden().getText() + "[i]) return i;")
            # self.writeToSolidity("    else return ")
            self.writeToSolidity("}")

            self.writeToSolidity("")
            self.writeToSolidity("function add_to_" + ctx.iden().Iden().getText() + " (" + ctx.datatype().getText()[9:-1] + " i) private returns (" + ctx.datatype().getText()[9:-1] + ") {")
            if self.verificationMode == "VeriSol":          #Added for VeriSol & making code straightforward
                self.writeToSolidity("    " + ctx.iden().Iden().getText() + "[address(i)] = true;")
            else:
                self.writeToSolidity("    " + ctx.iden().Iden().getText() + "[i] = true;")
            self.writeToSolidity("    return i;")
            self.writeToSolidity("}")

    def writeEnumDecl(self, ctx:CelestialParser.EnumDeclContext):
        enumType = ctx.name.Iden().getText()
        self.writeToSolidity("enum " + enumType)
        self.writeToSolidity("{")
        self.indentationLevel += 1
        enumValueString = ""
        for enumValue in ctx.iden():
            if enumValue.Iden().getText() == enumType:
                continue
            enumValueString += enumValue.Iden().getText()
            if enumValue != ctx.iden()[-1]:
                enumValueString += ", "
        self.writeToSolidity(enumValueString)
        self.indentationLevel -= 1
        self.writeToSolidity("}")

    def writeEventDecl(self, ctx:CelestialParser.EventDeclContext):
        argList = ""
        for datatype in ctx.datatype():
            argList += self.getSolidityDatatype(datatype)
            if datatype != ctx.datatype()[-1]:
                argList += ", "

        self.writeToSolidity("event " + ctx.name.Iden().getText() + "("+ argList + ");")

    def writeStruct(self, ctx:CelestialParser.StructDeclContext):
        self.writeToSolidity("struct " + ctx.name.Iden().getText())
        self.writeToSolidity("{")
        self.indentationLevel += 1
        for i in range(1, len(ctx.iden())):
            self.writeToSolidity(self.getSolidityDatatype(ctx.datatype(i-1)) + " " + ctx.iden(i).Iden().getText() + ";")
        self.indentationLevel -= 1
        self.writeToSolidity("}")

    def writeMethod(self, ctx:CelestialParser.MethodDeclContext):
        methodDeclString = ""
        if ctx.name:
            methodName = ctx.name.Iden().getText()
            
            params = ctx.methodParamList()
            paramString = ""
            if params:
                for param in params.methodParam():
                    paramType = self.getSolidityDatatype(param.datatype())
                    if paramType in ["string", "bytes"]:
                        paramString += paramType + " memory " + param.name.Iden().getText()
                    else:
                        paramString += paramType + " " + param.name.Iden().getText()
                    if param != params.methodParam()[-1]:
                        paramString += ", "
            
            methodDeclString = "function " + methodName + " (" + paramString + ")"

            if ctx.PRIVATE():
                methodDeclString += " private"
            else:
                methodDeclString += " public"

            if ctx.stateMutability():
                methodDeclString += " " + ctx.stateMutability().getText()

            # if (not (ctx.spec() and (ctx.spec().CREDIT() or ctx.spec().DEBIT()))) and (ctx.MODIFIES() and not ctx.modifies):
            #     methodDeclString += " view"

            if (ctx.spec() and ctx.spec().CREDIT()):
                methodDeclString += " payable"

            if ctx.RETURNS():
                methodDeclString += " returns (" + self.getSolidityDatatype(ctx.datatype())
                if ctx.returnval:
                    methodDeclString += " " + ctx.returnval.Iden().getText()
                methodDeclString += ")"
        elif ctx.RECEIVE():
            methodDeclString = "receive () external payable"
        elif ctx.FALLBACK() and ctx.spec() and ctx.spec().CREDIT():
            if self.verificationMode == "VeriSol":
                methodDeclString = "function () external payable"               #Added for Verisol
            else:
                methodDeclString = "fallback () external payable"
        elif ctx.FALLBACK():
            if self.verificationMode == "VeriSol":
                methodDeclString = "function () external"               #Added for Verisol
            else:
                methodDeclString = "fallback () external"
      
        methodDeclString += " {"

        self.writeToSolidity("")
        self.writeToSolidity(methodDeclString)
        self.indentationLevel += 1

    def exitWriteMethod(self):
        self.indentationLevel -= 1
        self.writeToSolidity("}")

    def writeallInvariants(self):       #Added for VeriSol
        self.writeToSolidity("")
        self.writeToSolidity("function ContractInvariant () private view {")
        self.indentationLevel += 1
        #
        self.writeToSolidity("VeriSol.ContractInvariant("+self.invariants_collected+");")
        self.indentationLevel -= 1
        self.writeToSolidity("}")

    def appendInvariantBody(self, ctx:CelestialParser.ExprContext, symbols, scope):     #Added for VeriSol
        if ctx.op and ctx.getChildCount() == 3:
            lhs = ctx.expr(0)
            rhs = ctx.expr(1)
            lhsExpr = self.getSolidityExpr(lhs, symbols, scope)
            rhsExpr = self.getSolidityExpr(rhs, symbols, scope)
            lhsExpr = lhsExpr.replace('sum_mapping', 'VeriSol.SumMapping')
            rhsExpr = rhsExpr.replace('sum_mapping', 'VeriSol.SumMapping')
            optr = "=="
            if ctx.op.text == "==" or ctx.op.text == "!=" or ctx.op.text == "<=" or ctx.op.text == ">=" or ctx.op.text == "<" or ctx.op.text == ">":   
                s = lhsExpr + " " + ctx.op.text + " " + rhsExpr
            elif ctx.op.text == "==>":
                s = "!(" + lhsExpr + ") || (" + rhsExpr +")"
            elif ctx.op.text == "<==>":
                s = "((!(" + lhsExpr + ") || (" + rhsExpr +")) && ( !(" + rhsExpr + ") || (" + lhsExpr +")))"

            if self.invariants_collected == "":
                self.invariants_collected = "("+ s +")"
            else:
                self.invariants_collected = self.invariants_collected + " && ("+ s +")"
        else:
            print ("Dropping the invariant not verifiable using VeriSol:"+ctx.getText())


    def writeConstructor(self, ctx:CelestialParser.ConstructorDeclContext):
        params = ctx.methodParamList()
        paramString = ""
        if params:
            for param in params.methodParam():
                paramString += self.getSolidityDatatype(param.datatype()) + " " + param.name.Iden().getText()
                if param != params.methodParam()[-1]:
                    paramString += ", "

        self.writeToSolidity("")
        self.writeToSolidity("constructor (" + paramString + ") public {")
        self.indentationLevel += 1

    def exitWriteConstructor(self):
        self.indentationLevel -= 1
        self.writeToSolidity("}")

    def exprType(self, ctx, symbols, scope, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=False):
        if (ctx.primitive()):
            primitiveCtx = ctx.primitive()
            if primitiveCtx.BoolLiteral():
                return "bool"
            elif primitiveCtx.IntLiteral() or primitiveCtx.INT_MIN() or primitiveCtx.INT_MAX():
                return "int"
            elif primitiveCtx.NullLiteral() or primitiveCtx.SENDER() or primitiveCtx.ADDR() or primitiveCtx.TXORIGIN() or primitiveCtx.BCOINBASE():
                return "address"
            elif primitiveCtx.StringLiteral():
                return "string"
            elif primitiveCtx.VALUE() or primitiveCtx.BALANCE() or primitiveCtx.UINT_MAX() or primitiveCtx.BDIFF() or primitiveCtx.BGASLIMIT() or primitiveCtx.BNUMBER() or primitiveCtx.BTIMESTAMP() or primitiveCtx.TXGASPRICE():
                return "uint"
            elif primitiveCtx.LOG():
                return "eventlog"
            elif primitiveCtx.THIS():
                return "address" # TODO: ContractType? or return scope
            elif primitiveCtx.NEW():
                identifierName = primitiveCtx.iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == identifierName and symbol.scope == "global":
                        return symbol.type
            else:
                varName = primitiveCtx.iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == varName and (symbol.scope == scope or symbol.scope == "global"):
                        return symbol.type
                if varName in self.enumTypes: # enum types are not stored in symbols (only their values are)
                    return varName

        elif (ctx.getChild(0) == ctx.LPAREN(0)):
            return self.exprType(ctx.getChild(1), symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)
        
        elif (ctx.DOT() and ctx.getChildCount() == 3 and ctx.field):
            lvalue = ctx.expr(0)
            rvalue = ctx.field
            lvalueType = self.exprType(lvalue, symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            if lvalueType in self.structs:
                structFieldName = rvalue.Iden().getText()
                for symbol in symbols:
                    if symbol.name == structFieldName and symbol.isStructField and symbol.fieldOfStruct == lvalueType:
                        return symbol.type
            # elif lvalueType in self.contracts:
            #     fieldName = rvalue.Iden().getText()
            #     for fields in self.fieldsOfContract[lvalueType]:
            #         if fieldName == fields[0]:
            #             return fields[1].getText()
            elif lvalue.getText() in self.enumTypes:
                return lvalue.getText()

        elif (ctx.array):
            lvalueType = self.exprType(ctx.array, symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            if lvalueType[-2:] == "[]":
                if (ctx.index):
                    if (ctx.index.MAPUPD()):
                        return lvalueType
                    return lvalueType[6:-1]
                elif (ctx.LENGTH()):
                    return "uint"                   
            elif lvalueType[0:7] == "mapping":
                start = lvalueType.find("=>") + 2 
                end = lvalueType.rfind("]")
                valueType = lvalueType[start:end]
                if ctx.index.MAPUPD():
                    return lvalueType
                else:
                    return valueType
            elif lvalueType[0:8] == "inst_map":
                return lvalueType[9:-1]
        
        elif (ctx.method and not ctx.DOT()):
            if (ctx.method.Iden().getText() == "sum_mapping"):
                return "uint"

            methodName = ctx.method.Iden().getText()
            if methodName in self.contracts: # ContractName(values_of_fields)
                return methodName

            else: # Normal method/function calls
                for symbol in symbols:
                    if methodName == symbol.name and symbol.scope == "global":
                        return symbol.type

        elif (ctx.SUB() and (ctx.getChildCount() == 2)):
            return "int"
        
        elif (ctx.LNOT() and (ctx.getChildCount() == 2)):
            return "bool"

        elif (ctx.PLUS() or ctx.SUB() or ctx.MUL() or ctx.DIV() or ctx.MOD()
                or ctx.SAFEADD() or ctx.SAFESUB() or ctx.SAFEMUL() or ctx.SAFEDIV() or ctx.SAFEMOD()):
            op1 = ctx.lhs
            op2 = ctx.rhs
            op1type = self.exprType(op1, symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            op2type = self.exprType(op2, symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            if (op2.primitive() and op2.primitive().IntLiteral()):
                if op1type == "int":
                    return "int"
                elif op1type == "uint":
                    return "uint"
            elif (op1.primitive() and op1.primitive().IntLiteral()):
                if op2type == "int":
                    return "int"
                elif op2type == "uint":
                    return "uint"
            else:
                if (op1type == op2type and op1type == "int"):
                    return "int"
                elif (op1type == op2type and op1type == "uint"):
                    return "uint"

        elif (ctx.LT() or ctx.GT() or ctx.GE() or ctx.LE() or ctx.IN()
                or ctx.EQ() or ctx.NE() or ctx.LAND() or ctx.LOR() or ctx.ITE()
                or ctx.IMPL() or ctx.BIMPL() or ctx.FORALL() or ctx.EXISTS()):
            return "bool"

        elif (ctx.MAPUPD()):
            lhsType = self.exprType(ctx.expr(0), scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            rhsType = self.exprType(ctx.expr(1), scope, isMethod, isFunctionCall, isIf, isPre, isPost)
            return "mapping(" + lhsType + "=>" + rhsType + ")"

        elif (ctx.ADD()):
            return ctx.contractName.Iden().getText()

        elif (ctx.logcheck()):
            return "eventlog"

        elif (ctx.PAYABLE()):
            return self.exprType(ctx.expr(0), symbols, scope, isMethod, isFunctionCall, isIf, isPre, isPost)

        elif (ctx.method and ctx.DOT()):
            if ctx.iden(0).Iden().getText() == "abi":
                if ctx.method.Iden().getText() in ["encode", "encodePacked", "encodeWithSelector", "encodeWithSignature"]:
                    return "bytes"

    def getSolidityExpr(self, ctx:CelestialParser.ExprContext, symbols, scope):
        if ctx.primitive():
            if ctx.primitive().VALUE():
                return "msg.value"
            elif ctx.primitive().BALANCE():
                return "address(this).balance"
            elif ctx.primitive().SENDER():
                return "msg.sender"
            elif ctx.primitive().TXORIGIN() or ctx.primitive().TXGASPRICE():
                return ctx.getText()
            elif ctx.primitive().BCOINBASE() or ctx.primitive().BDIFF() or ctx.primitive().BGASLIMIT() or ctx.primitive().BNUMBER() or ctx.primitive().BTIMESTAMP():
                return ctx.getText()
            elif ctx.primitive().BoolLiteral() or ctx.primitive().IntLiteral() or ctx.primitive().StringLiteral() or ctx.primitive().iden():
                return ctx.getText()
            elif ctx.primitive().INT_MIN():
                return "(int256(uint256(1) << 255))"
            elif ctx.primitive().INT_MAX():
                return "(int256(~(uint256(1) << 255)))"
            elif ctx.primitive().UINT_MAX():
                if self.verificationMode == "VeriSol":
                    return "(uint256(0) - uint256(1))"
                else:
                    return "(~uint256(0))"
            elif ctx.primitive().NullLiteral():
                return "address(0)"
            elif ctx.primitive().ADDR():
                return "address(" + ctx.primitive().getChild(2).getText() + ")"
            elif ctx.primitive().THIS():
                return "this"
        
        elif (ctx.getChild(0) == ctx.LPAREN(0)):
            return "(" + self.getSolidityExpr(ctx.expr(0), symbols, scope) + ")"
        
        elif ctx.array:
            if ctx.expr(0).primitive() and ctx.expr(0).primitive().iden() and ctx.LBRACK(): #TODO: Use exprType instead
                idenName = ctx.expr(0).primitive().iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == idenName and symbol.type[0:8] == "inst_map":
                        if self.verificationMode == "VeriSol":          #Added for VeriSol & making code straightforward
                            return "get_from_" + idenName + "(" + self.getSolidityExpr(ctx.index, symbols, scope) + ")"
                        else: 
                            return "get_from_" + idenName + "(" + symbol.type[9:-1] + "(payable(" + self.getSolidityExpr(ctx.index, symbols, scope) + ")))"

            if ctx.LBRACK():
                return self.getSolidityExpr(ctx.expr(0), symbols, scope) + "[" + self.getSolidityExpr(ctx.expr(1), symbols, scope) + "]"
            elif ctx.LENGTH():
                return self.getSolidityExpr(ctx.expr(0), symbols, scope) + ".length"
            
        elif ctx.method and not ctx.DOT():
            args = ctx.rvalueList()
            s = ctx.method.Iden().getText() + "("
            if args:
                for arg in args.rvalue():
                    s += self.getSolidityExpr(arg.expr(), symbols, scope)
                    if arg != args.rvalue()[-1]:
                        s += ", "
            s += ")"
            return s

        elif ctx.method and ctx.DOT():
            args = ctx.rvalueList()
            s = ctx.iden(0).Iden().getText() + "." + ctx.method.Iden().getText() + "("
            if args:
                for arg in args.rvalue():
                    s += self.getSolidityExpr(arg.expr(), symbols, scope)
                    if arg != args.rvalue()[-1]:
                        s += ", "
            s += ")"
            return s
        
        elif ctx.LNOT() or (ctx.getChildCount() == 2 and ctx.SUB()):
            return ctx.op.text + " " + self.getSolidityExpr(ctx.expr(0), symbols, scope)

        elif ctx.op and ctx.getChildCount() == 3:
            lhs = ctx.expr(0)
            rhs = ctx.expr(1)
            lhsExpr = self.getSolidityExpr(lhs, symbols, scope)
            rhsExpr = self.getSolidityExpr(rhs, symbols, scope)
            if ctx.op.text == "==":
                lhsType = self.exprType(lhs, symbols, scope)
                rhsType = self.exprType(rhs, symbols, scope)
                if (lhsType == "string"):
                    return "keccak256(bytes(" + lhsExpr + ") == keccak256(bytes(" + rhsExpr + "))"
            
            if ctx.op.text == "==>":                            #Added for VeriSol
                lhsType = self.exprType(lhs, symbols, scope)
                rhsType = self.exprType(rhs, symbols, scope)
                return "!("+ lhsExpr + ") || (" + rhsExpr + ")"

            if ctx.op.text == "<==>":                           #Added for VeriSol
                lhsType = self.exprType(lhs, symbols, scope)
                rhsType = self.exprType(rhs, symbols, scope)
                return "((!("+ lhsExpr + ") || (" + rhsExpr + ")) && (!("+ rhsExpr + ") || (" + lhsExpr + ")))"
      
            return lhsExpr + " " + ctx.op.text + " " + rhsExpr

        elif ctx.DOT() and ctx.getChildCount() == 3:
            return ctx.getText()
        
        elif ctx.SAFEADD() or ctx.SAFESUB() or ctx.SAFEMUL() or ctx.SAFEMOD() or ctx.SAFEDIV():
            self.arithLibFlag = True
            return "Safe_Arith." + ctx.getChild(0).getText() + "(" + self.getSolidityExpr(ctx.lhs, symbols, scope) + ", " + self.getSolidityExpr(ctx.rhs, symbols, scope) + ")"

        elif ctx.ADD():
            s = "("
            if ctx.rvalueList():
                for arg in ctx.rvalueList().rvalue():
                    s += self.getSolidityExpr(arg.expr(), symbols, scope)
                    if arg != ctx.rvalueList().rvalue()[-1]:
                        s += ", "
            s += ")"
            return "address(add_to_" + ctx.instmap.Iden().getText() + "(new " + ctx.contractName.Iden().getText() + s + "))"
            # return ctx.getChild(4).getText() + " " + ctx.getChild(5).getText() + " " + ctx.getChild(6).getText() + " " + ctx.getChild(7).getText()

        elif ctx.PAYABLE():
            return "payable(" + self.getSolidityExpr(ctx.expr(0), symbols, scope) + ")"

        # TODO: Cast Expr, Create Expr

    def getSolidityLvalueExpr(self, ctx:CelestialParser.LvalueContext, symbols, scope):
        if ctx.name:
            return ctx.name.Iden().getText()
        elif ctx.LBRACK():
            return self.getSolidityLvalueExpr(ctx.lvalue(), symbols, scope) + "[" + self.getSolidityExpr(ctx.expr(), symbols, scope) + "]"
        elif ctx.DOT():
            return ctx.getText()
    
    def writeStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        if ctx.LBRACE():
            # self.writeToSolidity(self.indentationLevel * "    ")
            self.writeToSolidity("{")
            self.indentationLevel += 1
            # for stmt in ctx.statement():
            #     self.writeToSolidity(self.indentationLevel * "    ")
            #     self.writeStatement(stmt)
            # self.indentationLevel -= 1
            # self.writeToSolidity(self.indentationLevel * "    ")
            # self.writeToSolidity("}\n")

        elif ctx.PUSH():
            self.writeToSolidity(self.getSolidityLvalueExpr(ctx.arrayName, symbols, scope) + ".push(" + self.getSolidityExpr(ctx.expr(0), symbols, scope) + ");")

        elif ctx.POP():
            self.writeToSolidity(self.getSolidityLvalueExpr(ctx.arrayName, symbols, scope) + ".pop();")

        # TODO: delete
        # elif ctx.DELETE():
        #     toDelete = ctx.lvalue()  
        #     self.writeToSolidity("delete " + )

        elif ctx.ASSERT():
            if self.verificationMode == "VeriSol":
                e = self.getSolidityExpr(ctx.expr(0), symbols, scope)
                self.writeToSolidity("assert (" + e.replace('sum_mapping', 'VeriSol.SumMapping') + ");")
            else:
                self.writeToSolidity("assert (" + self.getSolidityExpr(ctx.expr(0), symbols, scope) + ");")

        elif ctx.NEW():
            self.writeToSolidity(self.getSolidityLvalueExpr(ctx.assignTo, symbols, scope) + " = new " + ctx.iden().Iden().getText() + " ();")

        elif ctx.CALL() or ctx.CALLUINT() or ctx.CALLBOOL():
            callName = ""
            if ctx.CALL():
                callName = "call"
            elif ctx.CALLUINT():
                callName = "call_uint"
            elif ctx.CALLBOOL():
                callName = "call_bool"
            
            caller = self.getSolidityExpr(ctx.expr(0), symbols, scope)
            # s = "abi.encodeWithSignature(" + self.getSolidityExpr(ctx.rvalueList().rvalue()[0].expr(), symbols, scope)
            # for rvalue in ctx.rvalueList().rvalue()[1:]:
            #     s += ", " + self.getSolidityExpr(rvalue.expr(), symbols, scope)
            s = self.getSolidityExpr(ctx.rvalueList().rvalue(0).expr(), symbols, scope)
            s = caller + "." + callName + "(" + s + ");"

            # Set the lock to true to disallow re-entrancy due to '.call'
            # self.writeToSolidity("_lock_ = true;")
            if ctx.BOOL() and ctx.CALLBOOL():
                self.writeToSolidity("bool " + ctx.iden().getText() + " = " + s)
            elif ctx.UINT() and ctx.CALLUINT():
                self.writeToSolidity("uint " + ctx.iden().getText() + " = " + s)
            elif ctx.lvalue() and (ctx.CALLBOOL() or ctx.CALLUINT()):
                assignToExpr = self.getSolidityLvalueExpr(ctx.lvalue()[0], symbols, scope)
                self.writeToSolidity(assignToExpr + " = " + s)
            elif ctx.lvalue():
                assignToExpr = self.getSolidityLvalueExpr(ctx.lvalue()[0], symbols, scope)
                self.writeToSolidity("(" + assignToExpr + ", ) = " + s)
            else:
                self.writeToSolidity(s)
            
            # Set the lock to false after the execution of '.call'
            # self.writeToSolidity("_lock_ = false;")

        elif ctx.assignment:
            self.writeToSolidity(self.getSolidityLvalueExpr(ctx.assignTo, symbols, scope) + " = " + self.getSolidityExpr(ctx.rvalue().expr(), symbols, scope) + ";")

        elif ctx.IF():
            self.writeToSolidity("if (" + self.getSolidityExpr(ctx.expr(0), symbols, scope) + ")")
            # self.writeStatement(ctx.thenBranch)

        # TODO: forStatment

        elif ctx.otherContractInstance:
            s = self.getSolidityLvalueExpr(ctx.otherContractInstance, symbols, scope) + "." + ctx.method.Iden().getText() + "("
            args = ctx.rvalueList()
            if args:
                for arg in args.rvalue():
                    s += self.getSolidityExpr(arg.expr(), symbols, scope)
                    if arg != args.rvalue()[-1]:
                        s += ", "
            s += ");"
            self.writeToSolidity(s)

        # Method Call statement
        elif ctx.method and ctx.getChildCount() == 5:
            args = ctx.rvalueList()
            s = ctx.method.Iden().getText() + "("
            if args:
                for arg in args.rvalue():
                    s += self.getSolidityExpr(arg.expr(), symbols, scope)
                    if arg != args.rvalue()[-1]:
                        s += ", "
            s += ");"
            self.writeToSolidity(s)

        elif ctx.TRANSFER():
            to = self.getSolidityExpr(ctx.to, symbols, scope)
            amount = self.getSolidityExpr(ctx.amount, symbols, scope)
            if self.verificationMode == "VeriSol" and to!="msg.sender":     #Added for VeriSol.
                payableto = to.replace("(" ,"")
                payableto = payableto.replace(")" ,"")
                payableto = payableto.replace("payable" ,"")
                self.writeToSolidity("address payable "+payableto+" = address(uint160(address("+payableto+")));")
                self.writeToSolidity(payableto+".transfer(" + amount + ");")
                #self.writeToSolidity(to + ".call.value(" + amount + ").gas(2300)(\"\");")
            else:
                self.writeToSolidity(to + ".transfer(" + amount + ");")

            # self.writeToSolidity("if (address(this).balance < " + amount + ") revert (\"Insufficient balance\");")
            # if self.verificationMode == "VeriSol":
            #     self.writeToSolidity(to + ".call.value(" + amount + ").gas(2300)(\"\");")
            # else:
            #     self.writeToSolidity(to + ".call{value: (" + amount + "), gas: 2300}(\"\");")
            # self.indentationLevel += 1
            # self.writeToSolidity("if (!success)")
            # self.indentationLevel += 1
            # self.writeToSolidity("revert (\"<ErrorLog> Sending of ether failed\");")
            # self.indentationLevel -= 2

        elif ctx.EMIT():
            payloadString = ""
            for payloadExpr in ctx.expr():
                payloadString += self.getSolidityExpr(payloadExpr, symbols, scope)
                if payloadExpr != ctx.expr()[-1]:
                    payloadString += ", "
            eventName = ctx.event.Iden().getText()
            self.writeToSolidity("emit " + eventName + "(" + payloadString + ");")
        
        elif ctx.REVERT():
            self.writeToSolidity("revert (" + ctx.StringLiteral().getText() + ");")

    def exitWriteStatement(self, ctx:CelestialParser.StatementContext):
        if ctx.LBRACE():
            self.indentationLevel -= 1
            self.writeToSolidity("}")

    def writeElseStatement(self, ctx:CelestialParser.ElseStatementContext):
        self.writeToSolidity("else") #(" + self.getSolidityExpr(ctx.expr(0)) + ") ")

    def writeReturnStatement(self, ctx:CelestialParser.ReturnStatementContext, symbols, scope):
        if ctx.expr():
            self.writeToSolidity("return " + self.getSolidityExpr(ctx.expr(), symbols, scope) + ";")
        else:
            self.writeToSolidity("return;")

    def writeToSolidity(self, code):
        if code == "":
            self.output.write("\n")
        else:
            self.output.write("\n" + self.indentationLevel * "    " + code)
