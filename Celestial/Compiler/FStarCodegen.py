import copy
from os import makedirs
from os.path import join, dirname

from antlr4 import *

from CelestialLexer import CelestialLexer
from CelestialParser import CelestialParser
from CelestialParserListener import CelestialParserListener
from Symbol import Symbol


class FStarCodegen:

    def __init__(self, outputDir):
        """
        Per contract:
        ```
        fields:     Dictionary of field names -> datatype objects
                    fields["balance"] is always = None
                    dict(str, DatatypeContext)
        invariants: List of invariant names
                    list(str)
        methods:    Dictionary of method names -> datatype objects of return type
                    dict(str, DatatypeContext)
        functions:  Dict of function names -> funParamList object
                    dict(str, FunParamListContext)
        events:     List of event names
                    list(str)
        enumTypes:  List of enum types
                    list(str)
        enumValues: Dict of enum value -> enum type
                    dict(str, str)
        ```

        Per project:
        ```
        contract:         List of contract names (in the order of their declaration in the Celestial source)
                          The current contract is always the last element in the list
                          list(str)
        fieldsOfContract: Dict of contract names -> list of tuple of field names and datatype
                          The current contract is always the last element in the list of keys
                          dict(str, list(tuple(str, DatatypeContext)))  
        ```
        """
        self.output = None
        self.outputDir = outputDir
        self.moduleName = ""
        self.fieldPrefix = ""
        self.fields = {}
        self.initialFieldValues = {}
        self.invariants = [] # required for spec
        self.methods = {}    # TODO: can keep these and remove 'scope' in getFStarExpr?
        self.functions = {} # should modify this to store param and return types
        self.events = []
        self.structs = []
        self.enumTypes = []
        self.enumValues = {}
        self.indentationLevel = 0
        self.nestedLevel = 0
        self.temp = ""
        self.letBindFlag = False
        self.contracts = []
        self.invariantsOfContract = {}  # Dict with keys as contract names and value a list of invariants for that contract
        self.fieldsOfContract = {}      # Dict with keys as contract names and value a list of that contract's field names
        self.methodsOfContract = {}     # Dict with keys = contract names and values = dict with key as method name and value as tuple of returnvalue and list as params of that method in the contract
        self.returnVarNames = {}

    def clearCompilerVariables(self):
        self.fields = {}
        self.initialFieldValues = {}
        self.invariants = []
        self.methods = {}
        self.functions = {}
        self.events = []
        self.structs = []
        self.enumTypes = []
        self.enumValues = {}
        self.indentationLevel = 0
        self.nestedLevel = 0
        self.temp = ""
        self.letBindFlag = False
        self.returnVarNames = {}

    def existsMethod(self, method):
        return (method in self.methods)

    def existsFunction(self, function):
        return (function in self.functions)

    def existsField(self, field):
        return (field in self.fields)

    def existsInvariant(self, invariant):
        return (invariant in self.invariants)

    def addPrefix(self, varName):
        return self.fieldPrefix + "_" + varName

    def setModuleName(self, moduleName):
        """
        Sets the module name and field prefix
        """

        self.moduleName = moduleName
        self.fieldPrefix = moduleName.lower() #TODO: Change all prefixes to entirely lowercase

    def enterContract(self, contracts):
        self.clearCompilerVariables()
        self.fieldsOfContract[self.moduleName] = []
        filename = join(self.outputDir, self.moduleName) + ".fst"
        makedirs(dirname(filename), exist_ok=True)
        self.output = open(filename, "w")
        self.writeToFStar("(*Code generated by compiler*)\n")
        self.writeToFStar("\n")
        self.writeToFStar("module " + self.moduleName + "\n")
        self.writeToFStar("\n")
        self.writeToFStar("open FStar.Celestial\n")
        self.writeToFStar("open FStar.Celestial.Effect\n")
        self.writeToFStar("module CM = FStar.Celestial.ContractsMap\n")
        self.writeToFStar("open FStar.Mul\n")
        for contract in contracts:
            self.writeToFStar("open " + contract + "\n")
        self.writeToFStar("module M = FStar.Celestial.Map\n")
        self.writeToFStar("module L = FStar.List.Tot\n")
        self.writeToFStar("module A = FStar.Celestial.Array\n")
        self.writeToFStar("\n")

    def exitContract(self):
        self.output.close()

    def isArray(self, datatypeString):
        """
        Given a string representing a type, returns if it
            is an array or not
        """

        if datatypeString[-2:] == "[]":
            return True
        return False

    def isArrayOf(self, datatypeString):
        """
        Given a string of the form "type[]", returns 'type'
        """

        start = datatypeString.find("[")
        return datatypeString[0:start]

    def isMapping(self, datatypeString):
        """
        Given a string representing a type, returns if it
            is an array or not
        """

        if datatypeString[0:7] == "mapping":
            return True
        return False

    def getMapKeyType(self, mappingString):
        """
        Given a string of the form 'mapping(type1 => type2),
            returns the type of the key of the map 'type1'
        """

        start = mappingString.find("(") + 1
        end = mappingString.find("=>")
        return mappingString[start:end]

    def getMapValueType(self, mappingString):
        """
        Given a string of the form 'mapping(type1 => type2),
            returns the type of the value of the map 'type2'
        """

        start = mappingString.find("=>") + 2
        end = mappingString.rfind(")")
        return mappingString[start:end]


    def exprType(self, ctx:CelestialParser.ExprContext, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=False):
        if (ctx.primitive()):
            primitiveCtx = ctx.primitive()
            if primitiveCtx.BoolLiteral():
                return "bool"
            elif primitiveCtx.IntLiteral() or primitiveCtx.INT_MIN() or primitiveCtx.INT_MAX():
                return "int"
            elif primitiveCtx.NullLiteral() or primitiveCtx.SENDER() or primitiveCtx.ADDR() or primitiveCtx.TXORIGIN() or primitiveCtx.BCOINBASE():
                return "address"
            elif primitiveCtx.StringLiteral():
                return "string"
            elif primitiveCtx.VALUE() or primitiveCtx.BALANCE() or primitiveCtx.UINT_MAX() or primitiveCtx.BDIFF() or primitiveCtx.BGASLIMIT() or primitiveCtx.BNUMBER() or primitiveCtx.BTIMESTAMP() or primitiveCtx.TXGASPRICE():
                return "uint"
            elif primitiveCtx.LOG():
                return "eventlog"
            elif primitiveCtx.THIS():
                return "address" # TODO: ContractType? or return scope
            elif primitiveCtx.NEW():
                identifierName = primitiveCtx.iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == identifierName and symbol.scope == "global":
                        return symbol.type
            else:
                varName = primitiveCtx.iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == varName and (symbol.scope == scope or symbol.scope == "global"):
                        return symbol.type
                if varName in self.enumTypes: # enum types are not stored in symbols (only their values are)
                    return varName

        elif (ctx.getChild(0) == ctx.LPAREN(0)):
            return self.exprType(ctx.getChild(1), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
        
        elif (ctx.DOT() and ctx.getChildCount() == 3 and ctx.field):
            lvalue = ctx.expr(0)
            rvalue = ctx.field
            lvalueType = self.exprType(lvalue, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            if lvalueType in self.structs:
                structFieldName = rvalue.Iden().getText()
                for symbol in symbols:
                    if symbol.name == structFieldName and symbol.isStructField and symbol.fieldOfStruct == lvalueType:
                        return symbol.type
            elif lvalueType in self.contracts:
                fieldName = rvalue.Iden().getText()
                for fields in self.fieldsOfContract[lvalueType]:
                    if fieldName == fields[0]:
                        return fields[1].getText()
            elif lvalue.getText() in self.enumTypes:
                return lvalue.getText()

        elif (ctx.array):
            lvalueType = self.exprType(ctx.array, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            if self.isArray(lvalueType):
                if (ctx.index):
                    if (ctx.index.MAPUPD()):
                        return lvalueType
                    return self.isArrayOf(lvalueType)
                elif (ctx.LENGTH()):
                    return "uint"                   
            elif self.isMapping(lvalueType):
                valueType = self.getMapValueType(lvalueType)
                if ctx.index.MAPUPD():
                    return lvalueType
                else:
                    return valueType
            elif lvalueType[0:8] == "inst_map":
                return lvalueType[9:-1]
        
        elif (ctx.method and not ctx.DOT()):
            methodName = ctx.method.Iden().getText()
            if methodName in self.contracts: # ContractName(values_of_fields)
                return methodName

            else: # Normal method/function calls
                for symbol in symbols:
                    if methodName == symbol.name and symbol.scope == "global":
                        return symbol.type

        elif (ctx.SUB() and (ctx.getChildCount() == 2)):
            return "int"
        
        elif (ctx.LNOT() and (ctx.getChildCount() == 2)):
            return "bool"

        elif (ctx.PLUS() or ctx.SUB() or ctx.MUL() or ctx.DIV() or ctx.MOD()
                or ctx.SAFEADD() or ctx.SAFESUB() or ctx.SAFEMUL() or ctx.SAFEDIV() or ctx.SAFEMOD()):
            op1 = ctx.lhs
            op2 = ctx.rhs
            op1type = self.exprType(op1, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            op2type = self.exprType(op2, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            if (op2.primitive() and op2.primitive().IntLiteral()):
                if op1type == "int":
                    return "int"
                elif op1type == "uint":
                    return "uint"
            elif (op1.primitive() and op1.primitive().IntLiteral()):
                if op2type == "int":
                    return "int"
                elif op2type == "uint":
                    return "uint"
            else:
                if (op1type == op2type and op1type == "int"):
                    return "int"
                elif (op1type == op2type and op1type == "uint"):
                    return "uint"

        elif (ctx.LT() or ctx.GT() or ctx.GE() or ctx.LE() or ctx.IN() 
                or ctx.EQ() or ctx.NE() or ctx.LAND() or ctx.LOR() or ctx.ITE()
                or ctx.IMPL() or ctx.BIMPL() or ctx.FORALL() or ctx.EXISTS()):
            return "bool"

        elif (ctx.MAPUPD()):
            lhsType = self.exprType(ctx.expr(0), scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            rhsType = self.exprType(ctx.expr(1), scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            return "mapping(" + lhsType + "=>" + rhsType + ")"

        elif (ctx.ADD()):
            return ctx.contractName.Iden().getText()

        elif (ctx.logcheck()):
            return "eventlog"

        elif (ctx.PAYABLE()):
            return self.exprType(ctx.expr(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)

        elif (ctx.method and ctx.DOT()):
            if ctx.iden(0).Iden().getText() == "abi":
                if ctx.method.Iden().getText() in ["encode", "encodePacked", "encodeWithSelector", "encodeWithSignature"]:
                    return "bytes"

    # assumes already typechecked (for eg: does not allow map[array[int], int])
    # replace F* type names with those provided in the F* data structure library by aseem
    # implement similar function replacing the return strings with what needed, to get map/ds for types in Celestial/Solidity
    def getFStarDatatype(self, datatype:CelestialParser.DatatypeContext, symbols, isQuantifier=False):
        if (datatype.INT()):
            return "int"
        elif (datatype.UINT()):
            if isQuantifier:
                return "uint"
            else:
                return "uint"
        elif (datatype.ADDR()):
            return "address"
        elif (datatype.BOOL()):
            return "bool"
        elif (datatype.UINT8()):
            return "uint8"
        elif (datatype.BYTES()):
            return "bytes"
        elif (datatype.BYTES20()):
            return "bytes20"
        elif (datatype.BYTES32()):
            return "bytes32"
        elif (datatype.STRING()):
            return "string"
        elif (datatype.EVENTLOG()):
            return "log"
        elif (datatype.EVENT()): #TODO: Remove passing this as arg to functions
            return "string"
            # return "eventName"
        elif (datatype.arrayType):
            return "(a:(A.array " + self.getFStarDatatype(datatype.datatype(0), symbols, isQuantifier=isQuantifier) + "){A.def_of a == " + self.defaultValue(datatype.datatype(0).getText(), symbols) + "})"
        elif (datatype.MAP()):
            keyType = self.getFStarDatatype(datatype.datatype(0), symbols, isQuantifier=isQuantifier)
            comparator = "lt"
            if keyType == "string":
                comparator = "strcmp"
            return "(m:(M.t " + keyType + " " + self.getFStarDatatype(datatype.datatype(1), symbols) + " " + comparator + "){M.def_of m == " + self.defaultValue(datatype.datatype(1).getText(), symbols) + "})"
        elif (datatype.INSTMAP()):
            contractName = datatype.iden().Iden().getText()
            prefix = str.lower(contractName)
            return "(m:(M.t " + prefix + "_" + "address bool lt){M.def_of m == false /\\ ~ (M.contains m null)})"
        elif (datatype.iden()):
            datatypeName = datatype.iden().Iden().getText()
            if (datatypeName in self.contracts):
                return str.lower(datatypeName) + "_address"
            else:
                return self.fieldPrefix + "_" + datatype.iden().Iden().getText()

    def getFStarDatatypeS(self, datatype:str, symbols):
        if (datatype == "int"):
            return "int"
        elif (datatype == "uint"):
            return "uint"
        elif (datatype == "address"):
            return "address"
        elif (datatype == "bool"):
            return "bool"
        elif (datatype == "string"):
            return "string"
        elif self.isMapping(datatype):
            keyType = self.getMapKeyType(datatype)
            valueType = self.getMapValueType(datatype)
            keyType = self.getFStarDatatypeS(keyType, symbols)
            valueType = self.getFStarDatatypeS(valueType, symbols)
            comparator = "lt"
            if keyType == "string":
                comparator = "strcmp"
            return "(m:(M.t " + keyType + " " + valueType + " " + comparator + "){M.def_of m == " + self.defaultValue(valueType, symbols) + "})"
        elif self.isArray(datatype):
            arraytype = self.isArrayOf(datatype)
            return "(a:(A.array " + self.getFStarDatatypeS(arraytype, symbols) + "){A.def_of a == " + self.defaultValue(valueType, symbols) + "})"
        else: # structs and enums
            return self.addPrefix(datatype)

    def getFStarExpression(self, expr:CelestialParser.ExprContext, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=False):
        c = expr.getChild(0)
        self.indentationLevel += 1
        indentation = self.indentationLevel * "  "

        if expr.primitive() and not expr.logcheck():
            self.indentationLevel -= 1
            if c.BoolLiteral() or c.IntLiteral() or c.NullLiteral() or c.StringLiteral():
                return c.getText() #TODO Check scope and return contract_field if global
            elif c.THIS():
                return "self"
                # return c.getText() # TODO
            elif c.NEW() and c.iden():
                varName = c.iden().Iden().getText()
                for symbol in symbols:
                    if symbol.name == varName and (symbol.type[0:8] == "inst_map" or symbol.type in self.contracts) and isFunctionCall: #for instmaps in function call, pass a tuple
                        return "cs1." + self.addPrefix(varName) + ", " + "bst1"
                return "cs1." + self.addPrefix(varName)
            elif c.NEW() and c.BALANCE():
                return "b1"
            elif c.NEW() and c.LOG():
                return "l1"
            elif c.BALANCE():
                if isInvariant:
                    return self.addPrefix("balance")
                if isPre:
                    return "b"
                if isPost:
                    return "b0"
                if isMethod:
                    # return "let x1 = get_balance self in x1" 
                    # return "get_balance self"
                    return "balance"
            elif c.LOG(): #TODO:
                if isPre:
                    return "l"
                if isPost:
                    return "l0"
                return "l"
                # return "cs." + self.addPrefix("log")
                # if isInvariant:
                #     return "cs." + self.fieldPrefix + "_log"
                # elif isMethod:
                #     return "let x1 = get_" + self.fieldPrefix + "_log () in x1" 
            elif c.SENDER() or c.TXORIGIN() or c.TXGASPRICE() or c.VALUE() or c.INT_MIN() or c.INT_MAX() or c.UINT_MAX():
                return c.getText()
            elif c.BCOINBASE() or c.BDIFF() or c.BGASLIMIT() or c.BNUMBER() or c.BTIMESTAMP():
                return c.getText()
            elif c.ADDR():
                idenName = c.iden().Iden().getText()
                if idenName in self.fields:
                    if isInvariant:
                        return "cs." + self.addPrefix(idenName)
                    elif isMethod or isPre:
                        return "cs." + self.addPrefix(idenName)
                    elif isPost:
                        return "cs0." + self.addPrefix(idenName)
                else:
                    return idenName
            else:
                varName = c.iden().Iden().getText()
                if varName in self.fields: # TODO: if function arg has same name as field, then prob. Soln: put the elif branch above this
                    if isInvariant:
                        return "cs." + self.addPrefix(varName)
                    elif isPre:
                        # return "let x1 = " + self.addPrefix("get_" + varName) + " self in x1"
                        # return self.addPrefix("get_" + varName) + " self"
                        for symbol in symbols:
                            if symbol.name == varName and (symbol.type[0:8] == "inst_map" or symbol.type in self.contracts) and isFunctionCall:
                                return "cs." + self.addPrefix(varName) + ", " + "bst"
                        return "cs." + self.addPrefix(varName)
                    elif isMethod:
                        return "cs." + self.addPrefix(varName)
                    elif isPost:
                        for symbol in symbols:
                            if symbol.name == varName and (symbol.type[0:8] == "inst_map" or symbol.type in self.contracts) and isFunctionCall:
                                return "cs0." + self.addPrefix(varName) + ", " + "bst0"
                        return "cs0." + self.addPrefix(varName)
                elif varName in list(self.enumValues.keys()):
                    return varName[:1].upper() + varName[1:]
                else:
                    for sym in symbols:
                        if sym.name == varName:
                            if sym.type in self.contracts and not isMethod: #If it is a contract instance, retrieve it from the tupled bst
                                self.temp = sym.type # storing the type of contract in temp to retrieve its field prefix (when accessing its field in spec)
                                return "CM.sel (fst " + varName + ") (snd " + varName + ").cmap"
                            elif not isMethod and sym.type[0:8] == "inst_map":
                                return "fst " + varName
                            # if sym.type == "bool" and not isMethod: #Remove temporarily
                            #     return "(b2t " + varName + ")"
                            break

                    return varName
        
        elif (c == expr.LPAREN(0)):
            self.indentationLevel -= 1
            return "(" + self.getFStarExpression(expr.getChild(1), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ")"
        
        elif expr.method and not expr.DOT():
            methodName = expr.method.Iden().getText()

            if methodName in self.contracts: # ContractName(values_for_fields)
                contractFields = self.fieldsOfContract[methodName]
                prefix = str.lower(methodName) + "_"
                paramExprs = ""
                if expr.rvalueList():
                    i = 0
                    paramExprs = "{"
                    for param in expr.rvalueList().rvalue():
                        paramExpr = self.getFStarExpression(param.expr(), symbols, scope, isInvariant=isInvariant, isMethod=False, isFunctionCall=isFunctionCall, isIf=False, isPre=False, isPost=False)
                        paramExprs += " " + prefix + contractFields[i][0] + " = (" + paramExpr + ");"
                        i += 1
                    # paramExprs += " " + prefix + "balance = 0;"
                    paramExprs += "}"
                else:
                    paramExprs = self.defaultValue(methodName, symbols)
                return paramExprs
            else: # Normal method/function call
                isMethodCalled = False
                isFunction = False
                isStruct = False
                for sym in symbols:
                    if sym.name == methodName and sym.scope == "global":
                        if sym.isMethod:
                            isMethodCalled = True
                            break
                        elif sym.isFunction:
                            isFunction = True
                            break
                        elif sym.isStructType:
                            isStruct = True
                            break
                FStarExprString = ""
                x = 1
                i = 0
                xarr = {}
                structFieldNames = []
                if isStruct:
                    for sym in symbols:
                        if sym.fieldOfStruct == methodName:
                            structFieldNames.append(sym.name)

                # If the method/function call has arguments:
                if expr.rvalueList():
                    for arg in expr.rvalueList().rvalue():
                        argString = self.getFStarExpression(arg.expr(), symbols, scope, isInvariant, isMethod, True, isIf, isPre, isPost)
                        if " " in argString:
                            argString = "(" + argString + ")"
                        
                        # let-bind the argument in case it has further let-bindings
                        if isMethod and "=" in argString:
                            FStarExprString += "\nlet x" + str(x) + " = " + argString + " in"
                            argString = "x" + str(x)
                        xarr[x] = argString
                        x = x + 1
                        i = i + 1
                
                # Wrap the callee/struct in paranthesis/braces
                if isMethodCalled or isFunction:
                    if methodName in ["sum_mapping", "keccak256", "sha256", "ripemd160", "ecrecover"]:
                        FStarExprString += "(" + methodName
                    else:
                        FStarExprString += "(" + methodName #TODO: Have prefixes for method names in addition to fields
                elif isStruct:
                    FStarExprString += "{"

                # If it is a function, sender and value are not passed
                if isMethodCalled and methodName not in ["keccak256", "sha256", "ripemd160", "ecrecover"]:
                    FStarExprString += " self self 0 tx block"
                
                # Generate the final call/record string
                for i in range (1, x):
                    if isMethodCalled or isFunction:
                        FStarExprString += " " + xarr[i]
                    elif isStruct:
                        FStarExprString += " " + self.addPrefix(structFieldNames[i-1]) + " = " + xarr[i] + ";"

                self.indentationLevel -= 1
                if isMethodCalled or isFunction:
                    return FStarExprString + ")"
                else:
                    return FStarExprString + " }"

        elif expr.method and expr.DOT():
            methodName = expr.iden(0).getText() + "_" + expr.method.getText()
            xarr = {}
            FStarExprString = ""
            x = 1
            i = 0
            if expr.rvalueList():
                for arg in expr.rvalueList().rvalue():
                    argString = self.getFStarExpression(arg.expr(), symbols, scope, isInvariant, isMethod, True, isIf, isPre, isPost)
                    if " " in argString:
                        argString = "(" + argString + ")"
                    
                    # let-bind the argument in case it has further let-bindings
                    if isMethod and "=" in argString:
                        FStarExprString += "\nlet x" + str(x) + " = " + argString + " in"
                        argString = "x" + str(x)
                    xarr[x] = argString
                    x = x + 1
                    i = i + 1
            
            # Wrap the callee/struct in paranthesis/braces
            FStarExprString += "(" + methodName

            argString = xarr[1]
            
            # Generate the final call/record string
            for i in range (2, x):
                argString += ", " + xarr[i]
            
            self.indentationLevel -= 1
            return FStarExprString + "(" + argString + "))"

        elif (expr.SUB() and (expr.getChildCount() == 2)):
            self.indentationLevel -= 1
            # return "\nlet x1 = (-1) * (" + self.getFStarExpression(expr.expr(0), symbols, scope, isInvariant, isMethod) + " ) in x1"
            #TODO: x1 if =
            exprString = self.getFStarExpression(expr.expr(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            if " " in exprString:
                return "(-1) * (" + exprString + ")"
            else:
                return "(-1) * " + exprString

        elif (expr.LNOT()):
            op = expr.getChild(1)
            self.indentationLevel -= 1
            if isMethod:
                # return "\nlet x1 = (" + self.getFStarExpression(op, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ") in op_Negation x1"
                return "op_Negation (" + self.getFStarExpression(op, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ")"
            else:
                return "~ (" + self.getFStarExpression(op, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ")"
                # return "\nlet x1 = (" + self.getFStarExpression(op, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ") in ~ x1"

        elif (expr.array):
            s = ""
            if expr.index:
                if expr.index.MAPUPD():
                    updates = len(expr.index.MAPUPD())
                    s = "\n" + indentation + "let x1 = (" + self.getFStarExpression(expr.getChild(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ") in"
                    for i in range(updates):
                        s += "\n" + indentation + "let x2 = (" + self.getFStarExpression(expr.index.expr(2*i), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ") in"
                        s += "\n" + indentation + "let x3 = (" + self.getFStarExpression(expr.index.expr(2*i + 1), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ") in"
                        baseExprType = self.exprType(expr.getChild(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                        if self.isMapping(baseExprType) or baseExprType[0:8] == "inst_map":
                            s += "\n" + indentation + "let x1 = (M.upd x1 x2 x3) in"
                        elif self.isArray(baseExprType):
                            s += "\n" + indentation + "let x1 = (A.update x1 x2 x3) in"
                    s += "\n" + indentation + "x1"
                    # self.temp = "map"
                    # s += "\n" + indentation + "let x2 = (" + self.getFStarExpression(expr.index.expr(0), symbols, scope, isInvariant, isMethod) + ") in"
                    # s += "\n" + indentation + "let x3 = (" + self.getFStarExpression(expr.index.expr(1), symbols, scope, isInvariant, isMethod) + ") in"
                    # s += "\n" + indentation + "M.upd x1 x2 x3"
                else:
                    s = ""
                    c = expr.expr(0)
                    arrayOrMapAccessed = expr.getChild(0)
                    indexOrKey = expr.getChild(2)
                    arrayOrMapAccessedFStarExpression = self.getFStarExpression(expr.getChild(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    indexOrKeyFStarExpression = self.getFStarExpression(expr.getChild(2), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    
                    arrayOrMapAccessed = arrayOrMapAccessedFStarExpression
                    # if arrayOrMapAccessed.primitive() and arrayOrMapAccessed.getText() not in self.fields:
                        # arrayOrMapAccessed = arrayOrMapAccessed.getText()
                    # elif arrayOrMapAccessed.primitive() and arrayOrMapAccessed.getText() in self.fields:
                    #     arrayOrMapAccessed = "(" + arrayOrMapAccessedFStarExpression + ")"
                    # else:

                    # if isMethod:
                    #     s = "\n" + indentation + "let x1 = (" + arrayOrMapAccessedFStarExpression + ") in"
                    #     arrayOrMapAccessed = "x1"

                    if indexOrKey.primitive() and indexOrKey.getText() not in self.fields and "=" not in indexOrKey.getText(): #TODO: Check this
                        indexOrKey = indexOrKey.getText()
                    else:
                        # s += "\n" + indentation + "let x2 = (" + indexOrKeyFStarExpression + ") in"
                        # indexOrKey = "x2"
                        indexOrKey = indexOrKeyFStarExpression

                    isMap = False
                    isInstMap = False
                    isArray = False
                    varName = ""
                    if c.primitive() and c.primitive().iden():
                        varName = c.primitive().iden().Iden().getText()
                    else:
                        end = expr.getChild(0).getText().find("[")
                        varName = expr.getChild(0).getText()[0:end]
                        # Remove 'new()' to get the name of the variable
                        if varName[0:4] == "new(":
                            varName = varName[4:-1]
                    
                    for sym in symbols:
                        if sym.name == varName and sym.scope in [scope, "global"]:
                            if sym.isMap == True:
                                isMap = True
                            elif sym.type[0:8] == "inst_map":
                                isInstMap = True
                            elif self.isArray(sym.type):
                                isArray = True
                            break
                    
                    # Wrapping the map/array and key/index in paranthesis if they contain spaces
                    if " " in arrayOrMapAccessed:
                        arrayOrMapAccessed = "(" + arrayOrMapAccessed + ")"
                    if " " in indexOrKey:
                        indexOrKey = "(" + indexOrKey + ")"

                    if isMap:
                        if arrayOrMapAccessed[0] != "x" and indexOrKey[0] != "x":
                            s += "M.sel " + arrayOrMapAccessed + " " + indexOrKey
                        else:
                            s += "\n" + indentation + "M.sel " + arrayOrMapAccessed + " " + indexOrKey
                    elif isArray:
                        if arrayOrMapAccessed[0] != "x" and indexOrKey[0] != "x":
                            s += "A.select " + arrayOrMapAccessed + " " + indexOrKey
                        else:
                            s += "\n" + indentation + "A.select " + arrayOrMapAccessed + " " + indexOrKey
                    elif isInstMap:
                        if isMethod:
                            s += "\nif M.contains " + arrayOrMapAccessed + " " + indexOrKey + " then " + indexOrKey + " else null"
                        else: # Inst_Map access inside spec (should return instance from the tupled bst)
                            for symbol in symbols:
                                if symbol.name == expr.getChild(0).getText():
                                    self.temp = symbol.type[9:-1]
                                    break
                            arrayOrMapAccessedWithoutfst = expr.getChild(0).getText()#arrayOrMapAccessed[4:-1]
                            s += "CM.sel " + indexOrKey + " (snd " + arrayOrMapAccessedWithoutfst + ").cmap"
            
            elif expr.LENGTH():
                arrayExpr = self.getFStarExpression(expr.array, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                if " " in arrayExpr:
                    arrayExpr = "(" + arrayExpr + ")"
                s = "A.length " + arrayExpr
            self.indentationLevel -= 1
            return s

        elif (expr.ITE()):
            condition = expr.condition
            thenBranch = expr.thenBranch
            elseBranch = expr.elseBranch
            
            FStarCondition = self.getFStarExpression(condition, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf=True, isPre=isPre, isPost=isPost)
            FStarThen = self.getFStarExpression(thenBranch, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            FStarElse = self.getFStarExpression(elseBranch, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            FStarExprString = "if (" + FStarCondition + ") then\n"
            FStarExprString += "  (" + FStarThen + ")\n"
            FStarExprString += "else\n"
            FStarExprString += " (" + FStarElse + ")\n"
            
            self.indentationLevel -= 1
            return FStarExprString
        
        # TODO: DOT (eg: struct.field)
        elif (expr.DOT() and expr.getChildCount() == 3):
            lexpr = expr.expr(0)
            lvalueType = self.exprType(lexpr, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            rvalName = expr.field.Iden().getText()
            if lvalueType in self.structs:
                lvalueFStarExpression = self.getFStarExpression(lexpr, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                if " " in lvalueFStarExpression:
                    lvalueFStarExpression = "(" + lvalueFStarExpression + ")"
                return lvalueFStarExpression + "." + self.addPrefix(rvalName)
            elif lvalueType in self.enumTypes: # same as lexpr.getText() in self.enumTypes
                return rvalName[:1].upper() + rvalName[1:]
            elif lvalueType in self.contracts:
                rvalName = str.lower(lvalueType) + "_" + rvalName
                lvalueFStarExpression = self.getFStarExpression(lexpr, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                if " " in lvalueFStarExpression:
                    lvalueFStarExpression = "(" + lvalueFStarExpression + ")"
                return lvalueFStarExpression + "." + rvalName

        elif (expr.PLUS() or expr.SUB() or expr.MUL() or expr.DIV() or expr.MOD()
                or expr.LT() or expr.GT() or expr.GE() or expr.LE() or expr.EQ() or expr.NE()
                or expr.LAND() or expr.LOR()
                or expr.SAFEDIV() or expr.SAFEMUL() or expr.SAFEADD() or expr.SAFESUB()):
            self.temp = ""
            s = ""
            # isMethod = False
            # for sym in symbols:
            #     if sym.name == scope:
            #         if sym.isMethod:
            #             isMethod = True
            #         break
            
            op1 = expr.lhs
            op2 = expr.rhs
            op1Expr = self.getFStarExpression(op1, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            op2Expr = self.getFStarExpression(op2, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            # if op1.primitive() and op1.getText() not in self.fields and op1.getText() != "balance":
            #     op1 = op1.getText()
            ## if isMethod and ((op1.primitive() and op1.getText() in self.fields) or "=" in op1Expr):
            ##     s += "\n" + indentation + "let x1 = (" + op1Expr + ") in"
            ##     op1 = "x1"
            ## else:
            op1 = op1Expr
            # elif (not op1.primitive() and "let" not in op1Expr) and not op1.method:# or (not isMethod and not isInvariant): #self.letBindFlag:
            #     op1 = op1Expr                                   # op1.method check because can't use method calls directly in expressions just like fields (Con effect error)
            # else:
            #     s =  "\n" + indentation + "let x1 = (" + op1Expr + ") in"
            #     op1 = "x1"
            
            # if op2.primitive() and op2.getText() not in self.fields and op2.getText() != "balance":
            #     op2 = op2.getText()
            ## if isMethod and ((op2.primitive() and op2.getText() in self.fields) or "=" in op2Expr):
            ##     s += "\n" + indentation + "let x2 = (" + op2Expr + ") in"
            ##     op2 = "x2"
            ## else:
            op2 = op2Expr
            # else:
            #     op2 = op2Expr
            # elif (not op2.primitive() and "let" not in op2Expr) and not op2.method:# or (not isMethod and not isInvariant): #self.letBindFlag:
            #     op2 = op2Expr                                   # op2.method check because can't use method calls directly in expressions just like fields (Con effect error)
            # else:
            #     s += "\n" + indentation + "let x2 = (" + op2Expr + ") in"
            #     op2 = "x2"

            if " " in op1:
                op1 = "(" + op1 + ")"
            if " " in op2:
                op2 = "(" + op2 + ")"
                
            if op1[0] == "x" or op2[0] == "x":
                s += "\n" + indentation
                # self.letBindFlag = True

            if expr.PLUS():
                if not isMethod:
                    s += op1 + " + " + op2
                else:
                    # s += "(add_modula_lemma (" + op1 + ") (" + op2 + ");\n"
                    # s +=  "(" + op1 + " + " + op2 + ") % (uint_max + 1)"
                    s += "(_add " + op1 + " " + op2 + ")"
            elif expr.SUB():
                if not isMethod:
                    s += op1 + " - " + op2
                else:
                    # s += "(assert ((" + op1 + " - " + op2 + ") == (_sub " + op1 + " " + op2 + ")); "
                    s += "(_sub " + op1 + " " + op2 + ")"
            elif expr.MUL():
                if not isMethod:
                    s += op1 + " * " + op2
                else:
                    # s += "(multiply_modula_lemma (" + op1 + ") (" + op2 + ");\n"
                    s += "(_mul " + op1 + " " + op2 + ")"
            elif expr.DIV():
                if isMethod:
                    # s += "division_modulo_lemma " + op1 + " " + op2 + "; \n"
                    s += "(_div " + op1 + " " + op2 + ")"
                else:
                    s += op1 + " / " + op2
            elif expr.SAFEADD():
                # s += "(safe_add " + op1 + " " + op2 + ")"
                s += "(if " + op1 + " <= uint_max - " + op2 + " then (" + op1 + " + " + op2 + ") else revert \"Overflow error\")"
            elif expr.SAFESUB():
                # s += "(safe_sub " + op2 + " " + op1 + ")"
                s += "(if " + op2 + " <= " + op1 + " then (" + op1 + " - " + op2 + ") else revert \"Underflow error\")"
            elif expr.SAFEMUL():
                # s += "\nlet c = (" + op1 + " * " + op2 + ") in"
                # s += "(if c /" + op1 + " = " + op2 + " then (" + op1 + " * " + op2 + ") else revert \"Overflow error\")"
                s += "(safe_mul " + op1 + " " + op2 + ")"
            elif expr.SAFEDIV():
                s += "(if " + op2 + " <> 0 then (" + op1 + " / " + op2 + ") else revert \"Division by 0 error\")"
            elif expr.SAFEMOD():
                s += "(if " + op2 + " <> 0 then (" + op1 + " % " + op2 + ") else revert \"Division by 0 error\")"
            elif expr.MOD():
                s += op1 + " % " + op2
            elif expr.LT():
                s += op1 + " < " + op2
            elif expr.GT():
                s += op1 + " > " + op2
            elif expr.GE():
                s += op1 + " >= " + op2
            elif expr.LE():
                s += op1 + " <= " + op2
            elif expr.EQ():
                if not isMethod and not isIf:
                    # if self.temp == "map":
                    lhsType = self.exprType(expr.lhs, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) # same as rhsType
                    if self.isMapping(lhsType) or lhsType[0:8] == "inst_map":
                        s += "M.equal " + op1 + " " + op2
                    else:
                        s += op1 + " == " + op2
                else:
                    s += op1 + " = " + op2
            elif expr.NE():
                if isMethod or isIf:
                    s += op1 + " <> " + op2
                else:
                    s += op1 + " =!= " + op2
            elif expr.LAND():
                if not isMethod and not isIf:
                    s += op1 + " /\\ " + op2
                else:
                    s += op1 + " && " + op2
            elif expr.LOR():
                if not isMethod and not isIf:
                    s += op1 + " \\/ " + op2
                else:
                    s += op1 + " || " + op2

            self.indentationLevel -= 1
            return s
        
        elif (expr.IMPL() or expr.BIMPL()):
            op1 = expr.getChild(0)
            op2 = expr.getChild(2)
            op1Expr = self.getFStarExpression(op1, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            op2Expr = self.getFStarExpression(op2, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            # s =  "\n" + indentation + "let x1 = (" + op1Expr + ") in"
            # s += "\n" + indentation + "let x2 = (" + op2Expr + ") in"
            if expr.IMPL():
                s = "(" + op1Expr + " ==> " + op2Expr + ")"
            else:
                s = "(" + op1Expr + " <==> " + op2Expr + ")"
            self.indentationLevel -= 1
            return s

        elif (expr.FORALL() or expr.EXISTS()):
            syms = copy.deepcopy(symbols)
            for funParam in expr.funParamList().funParam():
                paramName = funParam.name.Iden().getText()
                paramType = funParam.datatype().getText()
                syms.append(Symbol(_name=paramName, _type=paramType, _scope=scope, _isQuantifierVar=True))
            
            s = "(" + expr.getChild(0).getText()
            for var in expr.funParamList().funParam():
                # if isInvariant:
                #     varName = "cs." + var.name.Iden().getText()
                # else:
                varName = var.name.Iden().getText()
                s += " (" + varName + ":" + self.getFStarDatatype(var.datatype(), symbols, isQuantifier=True) + ")"
            s += ". ("
            s += self.getFStarExpression(expr.expr(0), syms, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + "))\n"
            return s

        elif (expr.NEW() and expr.getChildCount() == 5): #TODO
            contractTypeName = expr.contractName.Iden().getText()
            FStarExprString = "("
            x = 1
            xarr = {}

            if expr.rvalueList():
                for arg in expr.rvalueList().rvalue():
                    paramExpr = self.getFStarExpression(arg.expr(), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    if (arg.expr().primitive() and arg.expr().getText() in self.fields) or "=" in paramExpr: # same as if "=" in paramExpr
                        FStarExprString += "\n" + indentation + "let x" + str(x) + " = (" + paramExpr + ") in"
                        paramExpr = "x" + str(x)
                    xarr[x] = paramExpr
                    x = x + 1
            if self.fieldsOfContract[contractTypeName]:
                newContractRecordString = "({"
                for fields in self.fieldsOfContract[contractTypeName]:
                    newContractRecordString += str.lower(contractTypeName)+ "_" + fields[0] + " = " + self.defaultValue(fields[1].getText(), symbols) + "; "
                newContractRecordString += "})"
            else:
                newContractRecordString = "()"
            s = ""
            s += "let contract_addr = create_contract " + newContractRecordString + " in "
            if "constructor" in self.methodsOfContract[contractTypeName].keys():
                s += "(" + str.lower(contractTypeName) + "_constructor self 0 tx block"
                for i in range (1, x):
                    FStarExprString += " " + xarr[i]
                s += "; "
            # return "(" + str.lower(contractTypeName) + "_constructor self 0)"
            s += "contract_addr"
            return s

        elif (expr.IN()):
            op1 = self.getFStarExpression(expr.expr(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            op2 = self.getFStarExpression(expr.expr(1), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            if " " in op1:
                op1 = "(" + op1 + ")"
            if " " in op2:
                op2 = "(" + op2 + ")"
            return "(M.contains " + op2 + " " + op1 + ")"

        elif (expr.DEFAULT()):
            return self.defaultValue(expr.datatype().getText(), symbols)

        elif (expr.ADD()):
            newContractOf = expr.contractName.Iden().getText()
            instmapName = expr.instmap.Iden().getText()
            FStarExprString = "("
            x = 1
            xarr = {}

            if expr.rvalueList():
                for arg in expr.rvalueList().rvalue():
                    paramExpr = self.getFStarExpression(arg.expr(), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    if (arg.expr().primitive() and arg.expr().getText() in self.fields) or "=" in paramExpr: # same as if "=" in paramExpr
                        FStarExprString += "\n" + indentation + "let x" + str(x) + " = (" + paramExpr + ") in"
                        paramExpr = "x" + str(x)
                    xarr[x] = paramExpr
                    x = x + 1
            if self.fieldsOfContract[newContractOf]:
                newContractRecordString = "({"
                for fields in self.fieldsOfContract[newContractOf]:
                    newContractRecordString += str.lower(newContractOf)+ "_" + fields[0] + " = " + self.defaultValue(fields[1].getText(), symbols) + "; "
                newContractRecordString += "})"
            else:
                newContractRecordString = "()"
            FStarExprString += "\nlet contract_addr = create_contract " + newContractRecordString + " in "
            if "constructor" in self.methodsOfContract[newContractOf].keys():
                # FStarExprString += "\nassume (sender <> contract_addr); // NEWLY CREATED CONTRACT CANNOT HAVE THE SAME ADDRESS AS THE SENDER"
                FStarExprString += "\nlet _ = " + str.lower(newContractOf) + "_constructor contract_addr self 0 tx block"
                for i in range (1, x):
                    FStarExprString += " " + xarr[i]
                self.indentationLevel -= 1
                FStarExprString += " in"
            FStarExprString += "\nlet _ = " + self.addPrefix("set_" + instmapName) + " self (M.upd cs." + self.addPrefix(instmapName) + " contract_addr true) in contract_addr)"
            # self.writeToFStar("\n" + indentation + "let cs = get_contract self in")
            
            return FStarExprString

        elif (expr.logcheck()):
            s = ""
            for logTuple in expr.logcheck():
                # If the log tuple is from an emit
                if logTuple.event:
                    eventName = self.addPrefix(logTuple.event.Iden().getText())
                    payloadStr = ""
                    for payloadExpr in logTuple.expr():
                        payloadStr += self.getFStarExpression(payloadExpr, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                        if payloadExpr != logTuple.expr()[-1]:
                            payloadStr += ", "

                    if " " in payloadStr:
                        payloadStr = "(" + payloadStr + ")"
                    s += "(mk_event null " + eventName + " " + payloadStr + ")::"

                elif logTuple.ETRANSFER():
                    receiverExprStr = self.getFStarExpression(logTuple.to, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    amountExprStr = self.getFStarExpression(logTuple.payload, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
                    if " " in receiverExprStr:
                        receiverExprStr = "(" + receiverExprStr + ")"
                    if " " in amountExprStr:
                        amountExprStr = "(" + amountExprStr + ")"
                    s += "(mk_event " + receiverExprStr + " eTransfer " + amountExprStr + ")::"
            
            # logName = self.getFStarExpression(expr.logName, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            logName = ""
            if expr.logName.NEW() and expr.logName.LOG():
                logName = "l1"
            elif expr.logName.iden():
                logName = expr.logName.getText()
            elif expr.logName.LOG() and isPre:
                logName = "l"
            elif expr.logName.LOG() and isPost:
                logName = "l0"
            
            # oldLogStr = expr.logName.Iden().getText() #self.getFStarExpression(expr.logName, symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost)
            s += logName

            return s

        elif (expr.PAYABLE()):
            self.indentationLevel -= 1
            return "(" + self.getFStarExpression(expr.expr(0), symbols, scope, isInvariant, isMethod, isFunctionCall, isIf, isPre, isPost) + ")"

    def getFStarExpressionLvalue(self, lvalue:CelestialParser.LvalueContext, symbols, scope):
        if lvalue.name:
            self.indentationLevel += 1
            varName = lvalue.iden().Iden().getText()
            if varName in self.fields:
                self.indentationLevel -= 1
                return "cs." + self.addPrefix(varName)
                # return "let x1 = " + self.addPrefix("get_" + varName) + " self in x1"
                # return "let x1 = get_" + self.fieldPrefix + "_" + varName + " () in x1"
            else:
                self.indentationLevel -= 1
                return varName
        
        elif lvalue.LBRACK():
            c = lvalue.lvalue()
            selectingFromExpr = self.getFStarExpressionLvalue(lvalue.getChild(0), symbols, scope)
            selectingIndexExpr = self.getFStarExpression(lvalue.getChild(2), symbols, scope)
            # s = "\n" + indentation + "let x1 = (" + self.getFStarExpressionLvalue(lvalue.getChild(0), symbols, scope) + ") in"
            # s += "\n" + indentation + "let x2 = (" + self.getFStarExpression(lvalue.getChild(2), symbols, scope) + ") in"
            isMap = False
            isArray = False
            isInstMap = False
            varName = ""
            if c.name:
                varName = c.iden().Iden().getText()
            else:
                end = lvalue.getChild(0).getText().find("[")
                varName = lvalue.getChild(0).getText()[0:end]
            for sym in symbols:
                if sym.name == varName and sym.scope in [scope, "global"]:
                    if sym.isMap:
                        isMap = True
                    elif self.isArray(sym.type):
                        isArray = True
                    elif sym.type[0:8] == "inst_map":
                        isInstMap = True
                    break
            if isMap:
                s =  "M.sel (" + selectingFromExpr + ") (" + selectingIndexExpr + ")"
            elif isInstMap:
                s = "if M.contains " + selectingFromExpr + " " + selectingIndexExpr + " then " + selectingIndexExpr + " else null"
            elif isArray:
                s =  "A.select (" + selectingFromExpr + ") (" + selectingIndexExpr + ")"
            self.indentationLevel -= 1
            return s

    def writeEventDeclarations(self):
        for event in self.events:
            self.writeToFStar("assume val " + self.addPrefix(event) + " : string\n")

    def writeEnums(self):
        for enumType in self.enumTypes:
            self.writeToFStar("type " + self.addPrefix(enumType) + " =\n")
        
        for enum in list(self.enumValues.keys()):
            self.writeToFStar("| " + enum[:1].upper() + enum[1:] + "\n")

    def writeStructDecl(self, structs, symbols):
        for struct in structs:
            self.writeToFStar("noeq type " + self.addPrefix(struct) + " = {\n")
            structFields = {}
            for sym in symbols:
                if sym.isStructField and sym.fieldOfStruct == struct:
                    structFields[sym.name] = self.getFStarDatatypeS(sym.type, symbols)
                    # self.writeToFStar("  " + self.fieldPrefix + "_")
            for structField in structFields.keys():
                self.writeToFStar("  " + self.addPrefix(structField) + " : " + structFields[structField])
                if structField != list(structFields.keys())[-1]:
                    self.writeToFStar(";")
                self.writeToFStar("\n")
            self.writeToFStar("}\n\n")

    def writeFieldRecord(self, symbols):
        if self.fields:
            self.writeToFStar("\nnoeq type t_" + str.lower(self.moduleName) + " = {")
            keys = list(self.fields.keys())
            for k in keys:
                self.fieldsOfContract[self.moduleName].append((k, self.fields[k]))
                self.writeToFStar("\n  " + self.addPrefix(k) + " : " + self.getFStarDatatype(self.fields[k], symbols) + ";")

            self.writeToFStar("\n}")
        else:
            self.writeToFStar("\ntype t_" + self.fieldPrefix + " = unit")

    def writeAddressAndLiveness(self):
        contractName = str.lower(self.moduleName)
        self.writeToFStar("\n")
        self.writeToFStar("\n(* Contract address type, liveness, and field range macros *)")
        self.writeToFStar("\n")
        self.writeToFStar("\ntype " + self.addPrefix("address") + " = contract t_" + contractName)
        self.writeToFStar("\nlet " + self.addPrefix("live") + " (c:" + self.addPrefix("address") + ") (bst:bstate) =")
        self.writeToFStar("\n  c `CM.live_in` bst.cmap")

        flag = False
        s = ""

        for field in self.fields:
            if self.fields[field].getText()[0:8] == "inst_map":
                contractType = self.fields[field].getText()[9:-1]
                contractAddressType = str.lower(contractType) + "_address"
                field = self.addPrefix(field)
                if flag:
                    s += "\n    /\\ (forall (i:" + contractAddressType + "). M.contains cs." + field + " i ==> i `CM.live_in` bst.cmap /\\ i <> c)"
                else:
                    s += "\n    (forall (i:" + contractAddressType + "). M.contains cs." + field + " i ==> i `CM.live_in` bst.cmap /\\ i <> c)"
                flag = True
        
        if flag:
            self.writeToFStar("\n  /\\ (let cs = CM.sel c bst.cmap in")
            s += "\n  )"
            self.writeToFStar(s)

    def writeFieldGetterSetters(self, symbols):
        c = self.fieldPrefix   # contract name

        self.writeToFStar("\n")
        self.writeToFStar("\n(* Field getters for contract " + self.moduleName + " *)")
        for field in list(self.fields.keys()):
            fp = self.addPrefix(field)   # prefixed field name
            self.writeToFStar("\n")
            self.writeToFStar("\nlet " + self.addPrefix("get_" + field) + " (c:" + self.addPrefix("address") + ")")
            self.writeToFStar("\n: StEth " + self.getFStarDatatype(self.fields[field], symbols, isQuantifier=False))
            self.writeToFStar("\n  (fun st -> c `" + c + "_live` st.current)")
            self.writeToFStar("\n  (fun st0 r st1 ->")
            self.writeToFStar("\n    st0 == st1 /\\ r == (CM.sel c st0.current.cmap)." + fp +")")
            self.writeToFStar("\n= let " + self.addPrefix("inst") + " = get_contract c in")
            self.writeToFStar("\n  " + self.addPrefix("inst") + "." + fp)
        
        self.writeToFStar("\n")
        self.writeToFStar("\n(* Field setters for contract " + self.moduleName + " *)")
        for field in list(self.fields.keys()):
            fp = self.addPrefix(field)   # prefixed field name
            self.writeToFStar("\n")
            self.writeToFStar("\nlet " + c + "_set_" + field + " (c:" + c + "_address) (_" + field + ":" + self.getFStarDatatype(self.fields[field], symbols) + ")")
            self.writeToFStar("\n: StEth unit")
            if self.fields[field].getText() == "uint":
                self.writeToFStar("\n  (fun st -> c `" + c + "_live` st.current")
                self.writeToFStar("\n              /\\ _" + field + " >= 0 /\\ _" + field + " <= uint_max)")
            elif self.fields[field].getText() == "int":
                self.writeToFStar("\n  (fun st -> c `" + c + "_live` st.current")
                self.writeToFStar("\n              /\\ _" + field + " >= int_min /\\ _" + field + " <= int_max)")
            elif (self.fields[field].getText()[0:8] == "inst_map"):
                contractType = self.fields[field].getText()[9:-1]
                contractAddressType = str.lower(contractType) + "_address"
                self.writeToFStar("\n  (fun st -> c `" + c + "_live` st.current")
                self.writeToFStar("\n              /\\ (forall (i:" + contractAddressType + "). M.contains _" + field + " i ==> " + str.lower(contractType) + "_live i st.current /\\ i <> c))")
            else:
                self.writeToFStar("\n  (fun st -> c `" + c + "_live` st.current)")
            self.writeToFStar("\n  (fun st0 _ st1 ->")
            self.writeToFStar("\n    modifies_cmap_only (Set.singleton c) st0.current st1.current /\\")
            self.writeToFStar("\n    " + c + "_live c st1.current /\\")
            self.writeToFStar("\n    (let instance0 = CM.sel c st0.current.cmap in")
            self.writeToFStar("\n     let instance1 = CM.sel c st1.current.cmap in")
            self.writeToFStar("\n    instance1 == { instance0 with " + fp + " = _" + field + " }))")
            self.writeToFStar("\n= let " + self.addPrefix("inst") + " = get_contract c in")
            self.writeToFStar("\n  let " + self.addPrefix("inst") + " = { " + self.addPrefix("inst") + " with " + fp + " = _" + field + " } in")
            self.writeToFStar("\n  set_contract c " + self.addPrefix("inst"))

    def writeInvariant(self, invariantName):
        self.writeToFStar("\n")
        self.writeToFStar("\nlet " + invariantName + " (self:" + self.addPrefix("address") + ") (bst:bstate{self `" + self.addPrefix("live") + "` bst}) : Type0 =")
        self.writeToFStar("\n  let " + self.addPrefix("balance") + " = pure_get_balance_bst self bst in")
        self.writeToFStar("\n  let cs = CM.sel self bst.cmap in")

    def writeInvariantBody(self, expr:CelestialParser.ExprContext, symbols, scope):
        self.writeToFStar("\n    " + self.getFStarExpression(expr, symbols, scope, isInvariant=True))

    def writeFunction(self, ctx:CelestialParser.FunDeclContext, symbols):
        functionName = ctx.iden().Iden().getText()
        self.writeToFStar("\n")
        self.writeToFStar("\nlet " + functionName)
        if ctx.funParamList():
            for parameter in ctx.funParamList().funParam():
                paramName = parameter.iden().Iden().getText()
                paramType = self.getFStarDatatype(parameter.datatype(), symbols)
                if (parameter.datatype().getText()[0:8] == "inst_map" or parameter.datatype().getText() in self.contracts):
                    contractType = ""
                    if parameter.datatype().getText()[0:8] == "inst_map":
                        contractType = str.lower(parameter.datatype().getText()[9:-1]) + "_address"
                    elif parameter.datatype().getText() in self.contracts:
                        contractType = str.lower(parameter.datatype().getText()) + "_address"
                    paramType = "tuple2 " + paramType + " bstate{forall (k:" + contractType + "). M.contains (fst " + paramName + ") k ==> k `CM.live_in` (snd " + paramName + ").cmap}"
                self.writeToFStar(" (" + paramName + ":" + paramType + ")")
        self.writeToFStar("\n= ")

    def writeFunctionBody(self, expr:CelestialParser.ExprContext, symbols, scope):
        self.writeToFStar(self.getFStarExpression(expr, symbols, scope))

    def writeConstructor(self, symbols, scope, ctx:CelestialParser.ConstructorDeclContext=None):
        self.writeToFStar("\n")
        self.writeToFStar("\nlet " + self.addPrefix("constructor") + " (self:" + self.addPrefix("address") + ") (sender:address) (value:uint) (tx:tx) (block:block)")
        if (ctx and ctx.methodParamList()):
            for parameter in ctx.methodParamList().methodParam():
                paramName = parameter.iden().Iden().getText()
                paramType = self.getFStarDatatype(parameter.datatype(), symbols)
                self.writeToFStar(" (" + paramName + ":" + paramType + ")")
        self.writeToFStar("\n: Eth1 unit")
        
        ################# Begin pre #################

        self.writeToFStar("\n  (fun bst -> ")
        self.writeToFStar("\n    " + self.addPrefix("live") + " self bst /\\")
        self.writeToFStar("\n    (let b = pure_get_balance_bst self bst in")   # balance
        self.writeToFStar("\n    let cs = CM.sel self bst.cmap in")           # contract record
        self.writeToFStar("\n      (sender <> null)")

        # Need to specify that all its fields are set to default values (other sum_mapping type invariants don't go through)
        if self.fields:
            for field in list(self.fields.keys()):
                fieldName = self.fields[field].getText()
                if fieldName not in self.contracts:
                    if fieldName in self.initialFieldValues:
                        fieldInitialValue = self.getFStarExpression(self.initialFieldValues[fieldName], symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
                        if " " in fieldInitialValue:
                            fieldInitialValue = "(" + fieldInitialValue + ")"
                    else:
                        fieldInitialValue = self.defaultValue(fieldName, symbols)
                    self.writeToFStar("\n      /\\ (cs." + self.addPrefix(field) + " == " + fieldInitialValue + ")")
                else:
                    self.writeToFStar("\n      /\\ (cs." + self.addPrefix(field) + " == null)")

        # Check if any pre-condition is specified
        if (ctx.spec().pre):
            # pre = self.getFStarPrePost(ctx.spec().pre, symbols, scope, isPre=True)
            pre = self.getFStarExpression(ctx.spec().pre, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
            self.writeToFStar("\n      /\\ (" + pre + ")")

        self.writeToFStar("\n    )")
        self.writeToFStar("\n  )")

        ################# Begin reverts clause #################

        # Constructor can revert only because of the arguments passed (and other methods called,
        #   whose arguments are in scope here at the callee), nothing else
        if not ctx.spec().reverts:
            self.writeToFStar("\n  (fun bst -> False)")
        else:
            self.writeToFStar("\n  (fun bst ->")

            flag = False
            if (ctx.spec().reverts):
                # reverts = self.getFStarPrePost(ctx.spec().reverts, symbols, scope, isPre=True)
                reverts = self.getFStarExpression(ctx.spec().reverts, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
                self.writeToFStar("\n    (" + reverts + ")")
                flag = True
                
            self.writeToFStar("\n  )")

        ################# Begin post #################
        
        self.writeToFStar("\n  (fun bst0 x bst1 ->")

        # If there is nothing in the user-written post-condition, then no need to retrieve cs0, etc. Post condition here is just the liveness
        if not ctx.spec().post and not ctx.spec().CREDIT() and not ctx.spec().DEBIT() and not ctx.MODIFIES() and not ctx.MODIFIESA():
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst1")     # liveness post condition
            # self.writeToFStar("\n    /\\ " + self.addPrefix("live") + " x bst1")     # liveness post condition
            # Check if there are any invariants defined
            if (self.invariants and not ctx.PRIVATE()):
                for invariant in self.invariants:
                    self.writeToFStar("\n    /\\ (" + invariant + " self bst1)")
            self.writeToFStar("\n  )")

        # If there is something in the user-written post-condition
        else:
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst1 /\\ (")    # liveness post condition
            self.writeToFStar("\n    let cs1 = CM.sel self bst1.cmap in")                # updated contract state
            self.writeToFStar("\n    let b0 = pure_get_balance_bst self bst0 in")        # balance
            self.writeToFStar("\n    let b1 = pure_get_balance_bst self bst1 in")        # new(balance)
            self.writeToFStar("\n    let l0 = bst0.log in")                              # log
            self.writeToFStar("\n    let l1 = bst1.log in")                              # new(log)

            flag = False

            # Check if there are any invariants defined
            if (self.invariants and not ctx.PRIVATE()):
                for invariant in self.invariants:
                    if invariant == self.invariants[0] and not flag:
                        self.writeToFStar("\n      (" + invariant + " self bst1)")
                    else:
                        self.writeToFStar("\n      /\\ (" + invariant + " self bst1)")
                flag = True

            # Check if any post-condition is specified
            if (ctx.spec().post):
                post = self.getFStarExpression(ctx.spec().post, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=True)
                # post = self.getFStarPrePost(ctx.spec().post, symbols, scope, isPre=False)
                if flag:
                    self.writeToFStar("\n      /\\ (" + post + ")")
                else:
                    self.writeToFStar("\n      (" + post + ")")
                flag = True

            # Check if the method is a credit or debit method
            # If both are present, then don't write any condition
            # If only DEBIT is given, then don't write any condition (b0 isn't available)
            # If only CREDIT is given, then write the following condition
            if (ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
                if flag:
                    self.writeToFStar("\n      /\\ (b1 == value)")
                else:
                    self.writeToFStar("\n      (b1 == value)")
                flag = True

            if (not ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
                if flag:
                    self.writeToFStar("\n      /\\ (bst0.balances == bst1.balances)")
                else:
                    self.writeToFStar("\n      (bst0.balances == bst1.balances)")
                flag = True

            if (ctx.MODIFIES() and not ctx.modifies) or not ctx.MODIFIES():
                if flag:
                    self.writeToFStar("\n      /\\ (l0 == l1)")
                else:
                    self.writeToFStar("\n      (l0 == l1)")
                flag = True

            # Check if the 'modifies_addresses' clause is used
            if (ctx.modifies_addrs):
                modifiesAddressesList = []
                for address in ctx.modifies_addrs.rvalue():
                    modifiesAddressesList.append(self.getFStarExpression(address.expr(), symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=True))
                stringOfSetOfAddresses = ""
                
                # The first element does not have an 'Set.union'
                if " " in modifiesAddressesList[0]:
                    stringOfSetOfAddresses = "(Set.singleton (" + modifiesAddressesList[0] + "))"
                else:
                    stringOfSetOfAddresses = "(Set.singleton " + modifiesAddressesList[0] + ")"

                # Union of singleton of each of the contract addresses
                for address in modifiesAddressesList[1:]:
                    if " " in address:
                        address = "(" + address + ")"
                    stringOfSetOfAddresses = "(Set.union (Set.singleton " + address + ") " + stringOfSetOfAddresses + ")"

                if flag:
                    self.writeToFStar("\n      /\\ CM.modifies_addrs " + stringOfSetOfAddresses + " bst0.cmap bst1.cmap")
                else:
                    self.writeToFStar("\n      CM.modifies_addrs " + stringOfSetOfAddresses + " bst0.cmap bst1.cmap")

            # Check if the modifies shorthand has been used
            # if (ctx.modifies): # non-empty modifies
            #     modifiesList = []
            #     if (ctx.spec().CREDIT() or ctx.spec().DEBIT()):
            #         modifiesList.append("log")
            #     for m in ctx.modifies.rvalue():
            #         modifiesList.append(m.expr().getText())
            #     fieldList = list(self.fields.keys())
            #     unmodifiedList = list(set(fieldList) - set(modifiesList))
            #     if not ctx.spec().CREDIT() and not ctx.spec().DEBIT():
            #         self.writeToFStar("\n      /\\ (b0 == b1)")
            #         if "log" not in modifiesList:
            #             self.writeToFStar("\n      /\\ (l0 == l1)") #TODO: what if external method is called that updates to log?
            #     for f in unmodifiedList:
            #         self.writeToFStar("\n      /\\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")")

            # else: # empty modifies
            #     if (ctx.MODIFIES() and not ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
            #         self.writeToFStar("\n      /\\ (bst0 == bst1)") # entire bstate remains same
            #         # for f in list(self.fields.keys()):
            #             # self.writeToFStar("\n    /\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")")

            #     elif (ctx.MODIFIES() and (ctx.spec().CREDIT() or ctx.spec().DEBIT())):
            #         for f in list(self.fields.keys()):
            #             self.writeToFStar("\n      /\\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")") # all fields remain same (but balance and log change)

            if not flag:
                self.writeToFStar("\n  True))") # closing parenthesis for ensures and let bindings
            else:
                self.writeToFStar("\n  ))") # closing parenthesis for ensures and let bindings

        self.writeToFStar("\n=")

        # if self.fields:
        #     newContractRecordString = "({"
        #     for field in list(self.fields.keys()):
        #         newContractRecordString += self.addPrefix(field) + " = " + self.defaultValue(self.fields[field].getText(), symbols) + "; "
        #     newContractRecordString += "})"
        # else:
        #     newContractRecordString = "()"
        # self.writeToFStar("\nlet self = create_contract " + newContractRecordString + " in")
    
        if ctx.spec().CREDIT():
            self.writeToFStar("\nlet b = get_balance self in")
            self.writeToFStar("\nlet _ = set_balance self (")
            self.writeToFStar("\n          if (b + value > uint_max) then (b + value - uint_max)")
            self.writeToFStar("\n          else (b + value)) in")
        # else:
        #     self.writeToFStar("\nlet _ = set_balance self 0 in")
        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_balance self in")

    # def exitWriteConstructor(self, ctx:CelestialParser.ConstructorDeclContext):
    #     self.writeToFStar("\nself")

    def writeMethod(self, ctx:CelestialParser.MethodDeclContext, symbols, scope):
        # Writing method definition
        if ctx.name:
            methodName = ctx.name.Iden().getText()
        elif ctx.RECEIVE():
            methodName = "receive"
        else:
            methodName = "fallback"

        self.writeToFStar("\n")
        self.writeToFStar("\nlet " + methodName + " (self:" + self.addPrefix("address") + ") (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)")
        if ctx.methodParamList():
            for parameter in ctx.methodParamList().methodParam():
                paramName = parameter.iden().Iden().getText()
                paramType = self.getFStarDatatype(parameter.datatype(), symbols)
                self.writeToFStar(" (" + paramName + ":" + paramType + ")")
        if ctx.datatype():
            methodReturnType = self.getFStarDatatype(ctx.datatype(), symbols)
        else:
            methodReturnType = "unit"
        self.writeToFStar("\n: Eth1 " + methodReturnType)

        ################# Begin pre #################

        self.writeToFStar("\n  (fun bst ->")

        # If there are no pre-conditions at all, just write the mandatory ones and don't retrieve cs, etc.
        if (not self.invariants or ctx.PRIVATE()) and not ctx.spec().PRE() and not ctx.spec().CREDIT():
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst")
            self.writeToFStar("\n  )")
        else:
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst /\\ (")  # liveness post condition
            self.writeToFStar("\n    let cs = CM.sel self bst.cmap in")               # contract state
            self.writeToFStar("\n    let b = pure_get_balance_bst self bst in")       # balance
            self.writeToFStar("\n    let l = bst.log in")                             # log

            conjunctFlag = False

            # Check if there are any invariants defined
            if (self.invariants and not ctx.PRIVATE()):
                for invariant in self.invariants:
                    if conjunctFlag:
                        self.writeToFStar("\n      /\\ (" + invariant + " self bst)")
                    else:
                        self.writeToFStar("\n      (" + invariant + " self bst)")
                        conjunctFlag = True

            # Check if any pre-condition is specified
            if (ctx.spec().pre):
                pre = self.getFStarExpression(ctx.spec().pre, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
                if conjunctFlag:
                    self.writeToFStar("\n      /\\ (" + pre + ")")
                else:
                    self.writeToFStar("\n      (" + pre + ")")
            
            self.writeToFStar("\n  ))")

        ################# Begin reverts clause #################

        if not ctx.spec().reverts and not ctx.spec().CREDIT() and not ctx.spec().rreverts:
            self.writeToFStar("\n  (fun bst -> False)")
        else:
            self.writeToFStar("\n  (fun bst ->")
            self.writeToFStar("\n    let cs = CM.sel self bst.cmap in")           # contract state
            self.writeToFStar("\n    let b = pure_get_balance_bst self bst in")   # balance
            self.writeToFStar("\n    let l = bst.log in")                         # log

            flag = False

            if (ctx.spec().reverts):
                reverts = self.getFStarExpression(ctx.spec().reverts, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
                self.writeToFStar("\n    (" + reverts + ")")
                flag = True

            if (ctx.spec().rreverts):
                rreverts = self.getFStarExpression(ctx.spec().rreverts, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=True, isPost=False)
                if flag:
                    self.writeToFStar("\n    \/ (" + rreverts + ")")
                else:
                    self.writeToFStar("\n    (" + rreverts + ")")
                flag = True

            if not flag:
                self.writeToFStar("\n  False)")
            else:
                self.writeToFStar("\n  )")

        ################# Begin post #################

        if ctx.returnval:
            retIden = ctx.returnval.Iden().getText()
            self.returnVarNames[methodName] = retIden
        else:
            retIden = "x"

        self.writeToFStar("\n  (fun bst0 " + retIden + " bst1 ->")
        
        # If there is nothing in the post-condition, then no need to retrieve cs0, etc. Post condition here is just the liveness
        if not ctx.spec().post and not ctx.spec().CREDIT() and not ctx.spec().DEBIT() and not ctx.MODIFIES() and not ctx.MODIFIESA():
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst1")     # liveness post condition
            # Check if there are any invariants defined
            if (self.invariants and not ctx.PRIVATE()):
                for invariant in self.invariants:
                    self.writeToFStar("\n     /\\ (" + invariant + " self bst1)")
            self.writeToFStar("\n  )")
            
        else:
            self.writeToFStar("\n    " + self.addPrefix("live") + " self bst1 /\\ (")    # liveness post condition
            self.writeToFStar("\n    let cs0 = CM.sel self bst0.cmap in")                # contract state 
            self.writeToFStar("\n    let cs1 = CM.sel self bst1.cmap in")                # updated contract state
            self.writeToFStar("\n    let b0 = pure_get_balance_bst self bst0 in")        # balance
            self.writeToFStar("\n    let b1 = pure_get_balance_bst self bst1 in")        # new(balance)
            self.writeToFStar("\n    let l0 = bst0.log in")                              # log
            self.writeToFStar("\n    let l1 = bst1.log in")                              # new(log)

            flag = False

            # Check if there are any invariants defined
            if (self.invariants and not ctx.PRIVATE()):
                for invariant in self.invariants:
                    if invariant == self.invariants[0] and not flag:
                        self.writeToFStar("\n    (" + invariant + " self bst1)")
                    else:
                        self.writeToFStar("\n      /\\ (" + invariant + " self bst1)")
                flag = True

            # Check if any post-condition is specified
            if (ctx.spec().post):
                post = self.getFStarExpression(ctx.spec().post, symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=True)
                # post = self.getFStarPrePost(ctx.spec().post, symbols, scope, isPre=False)
                if flag:
                    self.writeToFStar("\n      /\\ (" + post + ")")
                else:
                    self.writeToFStar("\n      (" + post + ")")
                flag = True

            # Check if the method is a credit or debit method
            # if (ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
            #     if flag:
            #         self.writeToFStar("\n      /\\ (b1 == b0 + value)")
            #     else:
            #         self.writeToFStar("\n      (b1 == b0 + value)")
            #     flag = True
            if (ctx.spec().DEBIT() and not ctx.spec().CREDIT()):
                if flag:
                    self.writeToFStar("\n      /\\ (b1 <= b0)")
                else:
                    self.writeToFStar("\n      (b1 <= b0)")
                flag = True
            elif (not ctx.spec().DEBIT() and not ctx.spec().CREDIT()):
                # Generate predicate that states all balances remain the same
                # This is true only if it is not a CREDIT or DEBIT method
                #   and, 'balance' isn't there in the MODIFIES clause
                balanceChanged = False
                if (ctx.modifies):
                    for m in ctx.modifies.rvalue():
                        if m.getText() == "balance":
                            balanceChanged = True
                            break
                if (not balanceChanged):
                    if flag:
                        self.writeToFStar("\n      /\\ (bst0.balances == bst1.balances)")
                    else:
                        self.writeToFStar("\n      (bst0.balances == bst1.balances)")
                    flag = True

            # Check if the 'modifies_addresses' clause is used
            if (ctx.modifies_addrs):
                modifiesAddressesList = []
                for address in ctx.modifies_addrs.rvalue():
                    modifiesAddressesList.append(self.getFStarExpression(address.expr(), symbols, scope, isInvariant=False, isMethod=False, isFunctionCall=False, isIf=False, isPre=False, isPost=True))
                stringOfSetOfAddresses = ""
                
                # The first element does not have an 'Set.union'
                if " " in modifiesAddressesList[0]:
                    stringOfSetOfAddresses = "(Set.singleton (" + modifiesAddressesList[0] + "))"
                else:
                    stringOfSetOfAddresses = "(Set.singleton " + modifiesAddressesList[0] + ")"

                # Union of singleton of each of the contract addresses
                for address in modifiesAddressesList[1:]:
                    if " " in address:
                        address = "(" + address + ")"
                    stringOfSetOfAddresses = "(Set.union (Set.singleton " + address + ") " + stringOfSetOfAddresses + ")"

                if flag:
                    self.writeToFStar("\n      /\\ CM.modifies_addrs " + stringOfSetOfAddresses + " bst0.cmap bst1.cmap")
                else:
                    self.writeToFStar("\n      CM.modifies_addrs " + stringOfSetOfAddresses + " bst0.cmap bst1.cmap")

            # Check if the modifies shorthand has been used
            if (ctx.modifies): # non-empty modifies
                
                # Make a list of all the modifies fields
                modifiesList = []
                for m in ctx.modifies.rvalue():
                    modifiesList.append(m.expr().getText())

                # Filter out the fields that are unmodified
                fieldList = list(self.fields.keys())
                unmodifiedList = list(set(fieldList) - set(modifiesList))

                # If the method is neither CREDIT or DEBIT and
                #   'balance' or 'log' are not specifed in the
                #   'modifies' clause, then they are unmodified
                if not ctx.spec().CREDIT() and not ctx.spec().DEBIT():
                    if "log" not in modifiesList:
                        if flag:
                            self.writeToFStar("\n      /\\ (l0 == l1)")
                        else:
                            self.writeToFStar("\n      (l0 == l1)")
                            flag = True

                # Generate the predicates for fields that are modified
                for f in unmodifiedList:
                    if not flag and f == unmodifiedList[0]:
                        self.writeToFStar("\n      (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")")
                    else:
                        self.writeToFStar("\n      /\\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")")

            else: # empty modifies
                if (ctx.MODIFIES()): # modifies talks only about its fields
                    if flag:
                        self.writeToFStar("\n      /\\ (cs0 == cs1)")
                    else:
                        self.writeToFStar("\n      (cs0 == cs1)")
                    flag = True
                    if (ctx.spec()):
                        if (not ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
                            self.writeToFStar("\n      /\\ (l0 == l1)")
                # if (ctx.MODIFIES() and not ctx.spec().CREDIT() and not ctx.spec().DEBIT()):
                #     self.writeToFStar("\n    /\\ (bst0 == bst1)") # entire bstate remains same
                #     # for f in list(self.fields.keys()):
                #         # self.writeToFStar("\n    /\\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")")

                # elif (ctx.MODIFIES() and (ctx.spec().CREDIT() or ctx.spec().DEBIT())):
                #     for f in list(self.fields.keys()):
                #         self.writeToFStar("\n    /\\ (cs0." + self.addPrefix(f) + " == cs1." + self.addPrefix(f) + ")") # all fields remain same (but balance and log change)

            if flag == False:
                self.writeToFStar("\n  True))")
            else:
                self.writeToFStar("\n  ))") # closing parenthesis for ensures

        self.writeToFStar("\n=")

        if ctx.spec().CREDIT():
            self.writeToFStar("\nlet b = get_balance self in")
            self.writeToFStar("\nlet _ = set_balance self (")
            self.writeToFStar("\n          if (b + value > uint_max) then (b + value - uint_max)")
            self.writeToFStar("\n          else (b + value)) in")

        if ctx.returnval:
            self.writeToFStar("\nlet " + ctx.returnval.Iden().getText() + ":" + self.getFStarDatatype(ctx.datatype(), symbols) + " = " + self.defaultValue(ctx.datatype().getText(), symbols) + " in")

        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_balance self in")

    #TODO: Use self.defaultValue()
    def writeVariable(self, ctx:CelestialParser.VarDeclContext, symbols, scope):
        self.writeToFStar("\nlet " + ctx.iden().Iden().getText() + ":")
        varType = self.getFStarDatatype(ctx.datatype(), symbols)
        self.writeToFStar(varType + " = (")
        if ctx.expr():
            self.writeToFStar(self.getFStarExpression(ctx.expr(), symbols, scope, isMethod=True))
        else:
            if ctx.datatype().arrayType:
                self.writeToFStar("A.create_empty (" + self.defaultValue(self.getFStarDatatype(ctx.arrayType, symbols), symbols) + ")")
            elif ctx.datatype().BOOL():
                self.writeToFStar("false")
            elif ctx.datatype().INT() or ctx.datatype().UINT():
                self.writeToFStar("0")
            elif ctx.datatype().STRING():
                self.writeToFStar("\"\"")
            elif ctx.datatype().ADDR():
                self.writeToFStar("null")
            elif ctx.datatype().getText() in self.contracts:
                self.writeToFStar("null")
            # TODO: Handle struct (and enum?) local vars
        self.writeToFStar(") in")

    def writePushStatement(self, ctx:CelestialParser.StatementContext, symbols, scope, arrayName):
        # All arrays are global only for Celestial v0.1
        valueToPush = self.getFStarExpression(ctx.value, symbols, scope, isMethod=True)
        lvalueToPushTo = self.getFStarExpressionLvalue(ctx.arrayName, symbols, scope)
        if "=" in valueToPush:
            self.writeToFStar("\nlet x1 = (" + valueToPush + ") in")
            valueToPush = "x1"
        if "=" in lvalueToPushTo:
            self.writeToFStar("\nlet x2 = (" + lvalueToPushTo + ") in")
            lvalueToPushTo = "x2"
        #TODO: Nested array push
        self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + ctx.arrayName.name.Iden().getText()) + " self (A.push " + lvalueToPushTo + " " + valueToPush + ") in")
        self.writeToFStar("\nlet cs = get_contract self in")
        # self.writeToFStar("let cs = {cs with " + self.addPrefix(ctx.arrayName.name.Iden().getText()) + " = (A.update x2 (A.length x2) x1)} in\n")
        # self.writeToFStar("set_" + self.fieldPrefix + "_" + ctx.name.name.Iden().getText() + "(A.update x2 (A.length x2) x1);\n") # this doesn't support multi dim arrays => have a get array name fn and use that
        # self.writeToFStar("let " + arrayName + " = (snoc " + arrayName + " x1) in\n") # local arrays, for when it is supported

    def writePopStatement(self, ctx:CelestialParser.StatementContext, symbols, scope, arrayName):
        arrayToPopFrom: self.getFStarExpressionLvalue(ctx.arrayName, symbols, scope)
        if " " in arrayToPopFrom:
            arrayToPopFrom = "(" + arrayToPopFrom + ")"
        
        self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + ctx.arrayName.name.Iden().getText()) + " self (A.pop " + arrayToPopFrom + ") in")
        self.writeToFStar("\nlet cs = get_contract self in")

    # TODO: Generalize lvalue to any lvalue and not just iden
    def writeDeleteStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        fieldName = ctx.toDelete.name.Iden().getText()
        fieldType = ""
        setter = self.addPrefix("set_" + fieldName) + " self"
        # getter = "(" + self.addPrefix("get_" + fieldName) + " self)"
        getter = "cs." + self.addPrefix(fieldName)
        for symbol in symbols:
            if symbol.name == fieldName:
                fieldType = symbol.type
                break
        if self.isMapping(fieldType):
            keyExpr = self.getFStarExpression(ctx.value, symbols, scope, isMethod=True)
            if "=" in keyExpr:
                self.writeToFStar("\nlet x1 = (" + keyExpr + ") in")
                keyExpr = "x1"
            self.writeToFStar("\nlet _ = "  + setter + " (M.delete " + getter + " " + keyExpr  + ") in")
            # self.writeToFStar(self.indentationLevel * "  " + "let cs = {cs with " + prefixedFieldName + " = (M.delete cs." + prefixedFieldName + " " + keyExpr + ")} in\n")
        elif self.isArray(fieldType):
            if ctx.value:
                indexExpr = self.getFStarExpression(ctx.value, symbols, scope, isMethod=True)
                if "=" in indexExpr:
                    self.writeToFStar("\nlet x1 = (" + indexExpr + ") in")
                    indexExpr = "x1"
                self.writeToFStar("\nlet _ = " + setter + " (A.delete " + getter + " " + indexExpr + ") in")
            else:
                arrValType = self.getFStarDatatypeS(fieldType[6:-1], symbols)
                self.writeToFStar("\nlet _ = " + setter + " (A.create_empty " + arrValType + ") in")
        elif fieldType[0:8] == "inst_map":
            keyExpr = self.getFStarExpression(ctx.value, symbols, scope, isMethod=True)
            if "=" in keyExpr:
                self.writeToFStar("\nlet x1 = (" + keyExpr + ") in")
                keyExpr = "x1"
            self.writeToFStar("\nlet _ = "  + setter + " (M.delete " + getter + " " + keyExpr  + ") in") #TODO: replace M with instmap library
            # self.writeToFStar(self.indentationLevel * "  " + "let cs = {cs with " + prefixedFieldName + " = (M.delete cs." + prefixedFieldName + " " + keyExpr + ")} in\n")
        else:
            self.writeToFStar("\nlet _ = " + setter + " " + self.defaultValue(fieldType, symbols) + " in")
        self.writeToFStar("\nlet cs = get_contract self in")

    # assumes just nested maps without arrays
    # TODO Generalize to arrays
    # TODO If no nesting, then write a case without x2 x1 etc
    def nestedMap(self, ctx:CelestialParser.LvalueContext, symbols, scope, x):
        self.nestedLevel += 1
        if ctx.LBRACK():
            if ctx.lvalue().name:
                # return "(M.sel " + ctx.name.Iden().getText() + " " + self.getFStarExpression(ctx.expr(), symbols, scope) + ")"
                exp = self.getFStarExpression(ctx.expr(), symbols, scope)
                mapName = ctx.lvalue().name.Iden().getText()
                if mapName in list(self.fields.keys()):
                    # r = "let x" + str(x+2) + " = (get_" + self.fieldPrefix + "_" + mapName + " () ) in\n"
                    # r = "let x" + str(x+2) + " = " + self.addPrefix("get_" + mapName) + " self in"
                    r = "let x" + str(x+2) + " = cs." + self.addPrefix(mapName) + " in\n"
                else: # TODO: Remove this? This case won't happen I think (check functions)
                    r = "\nlet x" + str(x+2) + " = (" + mapName + ") in"
                r += "\nlet x" + str(x+1) + " = (" + exp + ") in"
                r += "\nlet x" + str(x) + " = (M.sel x" + str(x+2) + " x" + str(x+1) + ") in"
                # if mapName in self.fields: # dont think there's a case otherwise
                #     mapName = self.addPrefix(mapName)
                self.temp = mapName
                return r
                # return "let x" + str(x) + " = (M.sel " + ctx.lvalue().name.Iden().getText() + " " + self.getFStarExpression(ctx.expr(), symbols, scope) + ") in\n"
            else:
                s = self.nestedMap(ctx.lvalue(), symbols, scope, x+2)
                exp = self.getFStarExpression(ctx.expr(), symbols, scope)
                # print (ctx.expr(0))
                r = s + "\nlet x" + str(x+1) + " = (" + exp + ") in"
                r += "\nlet x" + str(x) + " = (M.sel x" + str(x+2) + " x" + str(x+1) + ") in"
                return r
                # return s + "let x" + str(x) + " = (M.sel x" + str(x+1) + " " + exp + ") in\n"

    def writeAssignmentStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        rhsctx = ctx.rvalue().expr()
        rhs = self.getFStarExpression(rhsctx, symbols, scope, isMethod=True)
        indentation = self.indentationLevel * "  "

        # iden = value
        if ctx.assignTo.name:
            # if rhsctx.primitive() and rhsctx.getText() not in self.fields:
            #     rhs = rhsctx.primitive().getText()
            # else:
            if "=" in rhs or rhs == "balance" or rhsctx.method:
            # if "=" in rhs or rhs == "get_balance self" or rhsctx.method: #Changed way balance is retrieved
                self.writeToFStar("\nlet x1 = (" + rhs + ") in")
                rhs = "x1"
            varName = ctx.assignTo.name.getText()
            lvalueType = ""
            for sym in symbols:
                if sym.name == varName and sym.scope in [scope, "global"]:
                    lvalueType = sym.type
                    break

            if varName in self.fields:
                self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + varName) + " self " + rhs + " in")
                # self.writeToFStar("\n" + indentation + "let cs = get_contract self in")
                # self.writeToFStar("let cs = {cs with " + self.addPrefix(varName) + " = " + rhs +"} in\n")
            else:
                self.writeToFStar("\nlet " + varName + " = " + rhs + " in")

                # If a method call happens or .add() is called, contract state is updated, and hence has to be retrieved again
                # if rhsctx.method or rhsctx.ADD():
                #     self.writeToFStar("\nlet cs = get_contract self in")

        # iden[]* = value
        elif ctx.assignTo.LBRACK():
            if (ctx.assignTo.lvalue().name): # iden[] = value
                indexKeyctx = ctx.assignTo.expr()
                indexKey = self.getFStarExpression(indexKeyctx, symbols, scope, isMethod=True)
                if rhsctx.primitive() and rhsctx.getText() not in self.fields:
                    rhs = rhsctx.primitive().getText()
                else:
                    self.writeToFStar("\nlet x1 = (" + rhs + ") in")
                    rhs = "x1"
                if indexKeyctx.primitive() and indexKeyctx.getText() not in self.fields:
                    indexKey = indexKeyctx.primitive().getText()
                else:
                    self.writeToFStar("\nlet x2 = (" + indexKey + ") in")
                    indexKey = "x2"

                varName = ctx.assignTo.lvalue().iden().Iden().getText()
                varType = ""
                for sym in symbols:
                    if sym.name == varName and sym.scope in [scope, "global"]:
                        varType = sym.type
                        break
                lvalueType = self.getMapValueType(varType)
                if varName in self.fields:
                    # self.writeToFStar("\n" + indentation + "let " + varName + " = " + self.addPrefix("get_" + varName) + " self in")
                    self.writeToFStar("\n" + "let " + varName + " = cs." + self.addPrefix(varName) + " in")
                    if self.isArray(varType):
                        self.writeToFStar("\n" + "let _ = " + self.addPrefix("set_" + varName) + " self (A.update " + varName + " " + indexKey + " " + rhs + ") in") #TODO: Check if this works or if getter should be let bound
                        # self.writeToFStar("let cs = {cs with " + self.addPrefix(varName) + " = " + "(A.update cs." + self.addPrefix(varName) + " " + indexKey + " " + rhs +")} in\n")
                    elif self.isMapping(varType):
                        self.writeToFStar("\n" + "let _ = " + self.addPrefix("set_" + varName) + " self (M.upd " + varName + " " + indexKey + " " + rhs + ") in") #TODO: Check if this works or if getter should be let bound
                        # self.writeToFStar("let cs = {cs with " + self.addPrefix(varName) + " = " + "(M.upd cs." + self.addPrefix(varName) + " " + indexKey + " " + rhs +")} in\n")
                    # self.writeToFStar("\n" + indentation + "let cs = get_contract self in")
                else:
                    if self.isArray(varType):
                        self.writeToFStar("\n" + "let" + varName + " = (A.update " + varName + " " + indexKey + " " + rhs + ") in")
                    elif self.isMapping(varType):
                        self.writeToFStar("\n" + "let" + varName + " = (M.upd " + varName + " " + indexKey + " " + rhs + ") in")
            else: # iden[][][].. = value
                nestedMapString = self.nestedMap(ctx.assignTo, symbols, scope, 0)
                valueToWrite = "let x" + str(2*self.nestedLevel + 1) + " = (" + rhs + ") in"
                self.writeToFStar("\n" + valueToWrite)
                self.writeToFStar("\n" + nestedMapString)

                s = "\nlet _ = " + self.addPrefix("set_" + self.temp) + " self (M.upd x" + str(2*self.nestedLevel) + " x" + str(2*self.nestedLevel - 1) #TODO: Test
                # s = "let cs = {cs with " + self.temp + " = (M.upd x" + str(2*self.nestedLevel) + " x" + str(2*self.nestedLevel - 1)
                # s = "set_" + self.temp + " (M.upd x" + str(2*self.nestedLevel) + " x" + str(2*self.nestedLevel - 1)
                for i in range(2*self.nestedLevel - 1, 1, -2):
                    s += " (M.upd x" + str(i-1) + " x" + str(i - 2)
                s += " x" + str(2*self.nestedLevel + 1)
                for i in range(2*self.nestedLevel - 1, 1, -2):
                    s += ")"
                s += ") in"
                self.writeToFStar("\n" + indentation + s)
                # self.writeToFStar("\n" + indentation + "let cs = get_contract self in")
                self.nestedLevel = 0
        
        elif ctx.assignTo.DOT():
            if " " in rhs and rhs[0] != "(":
                rhs = "(" + rhs + ")"
            self.writeToFStar("\nlet x1 = " + rhs + " in")
            if ctx.assignTo.lvalue().LBRACK(): #TODO: Complete this
                fieldName = ctx.assignTo.lvalue().lvalue().name.getText() # field[e].f = x
                fieldKey  = self.getFStarExpression(ctx.assignTo.lvalue().expr(), symbols, scope, isMethod=True)
                structFieldUpdated = ctx.assignTo.field.Iden().getText()
                self.writeToFStar("\nlet x2 = cs." + self.addPrefix(fieldName) + " in")
                self.writeToFStar("\nlet x3 = " + fieldKey + " in")
                self.writeToFStar("\nlet x4 = M.sel x2 x3 in")
                self.writeToFStar("\nlet x5 = M.upd x2 x3 ({x4 with " + self.addPrefix(structFieldUpdated) + " = x1}) in")
                self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + fieldName) + " self x5 in")
                # structName = ""
                # for symbol in symbols:
                #     if symbol.isStructField and symbol.name == structFieldUpdated:
                #         structName = symbol.fieldOfStruct
                #         break
                # structObjectStr = ""
                # for symbol in symbols:
                #     if symbol.isStructField and symbol.fieldOfStruct:
                #         if symbol.name == structFieldUpdated:
                #             structObjectStr += self.addPrefix(symbol.name) + " = x1; "
                #         else:
                #             structObjectStr 

        self.writeToFStar("\nlet cs = get_contract self in")

    def writeCallStatement(self, ctx:CelestialParser.StatementContext, symbols, scope, reentrancyReverts):
        reentrancyRevertsStrings = []
        for expr in reentrancyReverts:
            conditionString = self.getFStarExpression(expr, symbols, scope, isMethod=True)
            if conditionString not in reentrancyRevertsStrings:
                reentrancyRevertsStrings.append(conditionString)
        
        reentrancyRevertsString = ""
        if reentrancyRevertsStrings:
            reentrancyRevertsString = "(" + reentrancyRevertsStrings[0] + ")"
            for string in reentrancyRevertsStrings[1:]:
                reentrancyRevertsString += " /\ (" + string + ")"

        if reentrancyRevertsString:
            self.writeToFStar("\nassert (" + reentrancyRevertsString + ");")

        callName = ""
        if ctx.CALLBOOL():
            callName = "call_bool"
        elif ctx.CALLUINT():
            callName = "call_uint"
        else:
            callName = "unknown_call"
        
        argExpr = ctx.rvalueList().rvalue(0).expr()
        argString = self.getFStarExpression(argExpr, symbols, scope, isMethod=True)
        if " " in argString:
            argString = "(" + argString + ")"

        # If the return value of the '.call' is assigned to a variable
        if ctx.ASSIGN():
            if ctx.lvalue() and ctx.lvalue()[0].name:
                varName = ctx.lvalue()[0].name.getText()
                if varName in self.fields:
                    self.writeToFStar("\nlet x1 = " + callName + " self " + argString + " in")
                    self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + varName) + " self (x1) in")
                else:
                    self.writeToFStar("\nlet " + varName + " = " + callName + " self " + argString + " in")
            # TODO:
            # elif ctx.lvalue()...
            elif ctx.BOOL():
                self.writeToFStar("\nlet " + ctx.getChild(1).getText() + ":bool = " + callName + " self " + argString + " in")
            elif ctx.UINT():
                self.writeToFStar("\nlet " + ctx.getChild(1).getText() + ":uint = " + callName + " self " + argString + " in")
        else:
            self.writeToFStar("\nlet _ = " + callName + " self " + argString + " in")

        # Fetching balance since '.call' might change balance
        self.writeToFStar("\nlet balance = get_balance self in")

    def writeNewStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        newContractOf = ctx.iden().Iden().getText()
        if self.fieldsOfContract[newContractOf]:
            newContractRecordString = "({"
            for fields in self.fieldsOfContract[newContractOf]:
                newContractRecordString += str.lower(newContractOf)+ "_" + fields[0] + " = " + self.defaultValue(fields[1].getText(), symbols) + "; "
            newContractRecordString += "})"
        else:
            newContractRecordString = "()"

        self.writeToFStar("\nlet contract_addr = create_contract " + newContractRecordString + " in ")
        if "constructor" in self.methodsOfContract[newContractOf].keys():
            # rhs = "\nassume (sender <> contract_addr); // NEWLY CREATED CONTRACT CANNOT HAVE THE SAME ADDRESS AS THE SENDER"
            rhs = "\nlet x = (" + str.lower(newContractOf) + "_constructor contract_addr self 0 tx block"
            if ctx.rvalueList():
                params = ctx.rvalueList().rvalue()
                for param in params:
                    paramExpr = self.getFStarExpression(param.expr(), symbols, scope, isMethod=True)
                    rhs += " (" + paramExpr + ")"
            rhs += ") in"
            self.writeToFStar("\n" + rhs)
        # rhs += "\nx"

        if ctx.assignTo.name:
            contractInstanceName = ctx.assignTo.name.Iden().getText()
            # TODO: For local instnaces also
            self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + contractInstanceName) + " self contract_addr in")

            # self.writeToFStar("\nlet cs = {cs with " + self.addPrefix(contractInstanceName) + " = " + rhs + "} in") #No constructor arguments for now

        elif ctx.assignTo.LBRACK():
            nestedMapString = self.nestedMap(ctx.assignTo, symbols, scope, 0)
            valueToWrite = "let x" + str(2*self.nestedLevel + 1) + " = " + rhs + " in\n"
            self.writeToFStar(valueToWrite)
            self.writeToFStar(nestedMapString)
            # s = "\nlet cs = {cs with " + self.temp + " = (M.upd x" + str(2*self.nestedLevel) + " x" + str(2*self.nestedLevel - 1)
            s = "\nlet _ =" + self.addPrefix("set_" + self.temp) + " (M.upd x" + str(2*self.nestedLevel) + " x" + str(2*self.nestedLevel - 1)
            for i in range(2*self.nestedLevel - 1, 1, -2):
                s += " (M.upd x" + str(i-1) + " x" + str(i - 2)
            s += " x" + str(2*self.nestedLevel + 1)
            for i in range(2*self.nestedLevel - 1, 1, -2):
                s += ")"
            s += " in\n"
            self.writeToFStar(s)
            self.nestedLevel = 0

    def writeIfStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        if scope in self.returnVarNames:
            retIden = self.returnVarNames[scope]
        else:
            retIden = "_"
        ifCondition = self.getFStarExpression(ctx.expr(0), symbols, scope, isMethod=True, isIf=True)
        if (ctx.expr(0).primitive() and ctx.expr(0).getText() not in self.fields) or "=" not in ifCondition:
            self.writeToFStar("\nlet " + retIden + " = (if (" + ifCondition + ") then begin")
        else:
            self.writeToFStar("\nlet x1 = (" + ifCondition + ") in")
            self.writeToFStar("\nlet " + retIden + " = (if x1 then begin")

    # if-condition without an else branch in CelLang
    def endIfWithoutElse(self, scope):
        if scope in self.returnVarNames:
            retIden = self.returnVarNames[scope]
        else:
            retIden = "()"
        self.writeToFStar("\n" + retIden + " end")
        self.writeToFStar("\nelse " + retIden + ") in")
        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_balance self in")

    # else branch and ending if branch
    def writeElseStatement(self, ctx:CelestialParser.ElseStatementContext, scope):
        if scope in self.returnVarNames:
            retIden = self.returnVarNames[scope]
        else:
            retIden = "()"
        self.writeToFStar("\n" + retIden + " end")
        self.writeToFStar("\nelse begin")
    
    # ending the else branch
    def endElse(self, ctx:CelestialParser.ElseStatementContext, scope):
        if scope in self.returnVarNames:
            retIden = self.returnVarNames[scope]
        else:
            retIden = "()"
        self.writeToFStar("\n" + retIden + " end) in")
        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_contract self in")

    def writeReturn(self, methodName):
        returnType = self.methods[methodName]
        if returnType is None:
            self.writeToFStar("\n()")
        elif returnType.BOOL():
            self.writeToFStar("\ntrue")
        elif returnType.INT() or returnType.UINT():
            self.writeToFStar("\n0")
        elif returnType.ADDR():
            self.writeToFStar("\nnull")

    def writeMethodCallStatement(self, ctx:CelestialParser.StatementContext, symbols, scope, isVoid):
        methodName = ctx.iden().Iden().getText()
        if (ctx.rvalueList()):
            params = ctx.rvalueList().rvalue()
            x = 1
            i = 0
            xarr = {}
            for param in params:
                paramExpr = self.getFStarExpression(param.expr(), symbols, scope, isMethod=True)
                if (param.expr().primitive() and param.expr().getText() in self.fields) or "=" in paramExpr: # same as if "=" in paramExpr
                #     paramExpr = param.expr().getText()
                # else:
                    self.writeToFStar("\nlet x" + str(x) + " = (" + paramExpr + ") in")
                    paramExpr = "x" + str(x)
                xarr[x] = paramExpr
                i = i + 1
                x = x + 1
            
            self.writeToFStar("\nlet _ = (" + methodName + " self self 0 tx block")
            for i in range(1, x):
                self.writeToFStar(" " + xarr[i])
            self.writeToFStar(") in")
        else:
            self.writeToFStar("\nlet _ = (" + methodName + " self self 0 tx block) in")
        self.writeToFStar("\nlet cs = get_contract self in")

    def writeCtAssignmentStatement(self, ctx, symbols, scope):
        methodName = ctx.iden().Iden().getText()
        methodArgs = ""
        if ctx.rvalueList():
            params = ctx.rvalueList().rvalue()
            for param in params:
                paramExpr = self.getFStarExpression(param.expr(), symbols, scope, isMethod=True)
                methodArgs += " (" + paramExpr + ")"
        otherContractInstanceName = self.getFStarExpressionLvalue(ctx.otherContractInstance, symbols, scope)
        if " " in otherContractInstanceName:
            otherContractInstanceName = "(" + otherContractInstanceName + ")"

        contractType = ""
        for symbol in symbols:
            if symbol.name == otherContractInstanceName:
                contractType = symbol.type
                break
        
        self.writeToFStar("\nlet bst = (get ()).current in")
        for invariant in self.invariantsOfContract[contractType]:
            self.writeToFStar("\nassume (" + invariant + " " + otherContractInstanceName + " bst); // META-ARGUMENT: CONTRACT INVARIANTS ALWAYS HOLD AT CONTRACT BOUNDARIES AND HENCE IS ALWAYS TRUE")
        # self.writeToFStar("\nassume (sender <> " + otherContractInstanceName + "); // " + otherContractInstanceName + " CANNOT BE EQUAL TO sender AND HENCE IS ALWAYS TRUE")

        if ctx.assignTo.name:
            self.writeToFStar("\nlet x1 = " + methodName + " " + otherContractInstanceName + " self 0 tx block" + methodArgs + " in")
            assignTo = ctx.assignTo.name.Iden().getText()
            if assignTo in self.fields:
                self.writeToFStar("\nlet _ = " + self.addPrefix("set_" + assignTo) + " self x1 in")
                self.writeToFStar("\nlet cs = get_contract self in")
                self.writeToFStar("\nlet balance = get_balance self in")
            else:
                self.writeToFStar("\nlet " + assignTo + " = x1 in")
                self.writeToFStar("\nlet balance = get_balance self in")
       # elif assignTo.lvalue(): # if writing to an array, map, etc

    def writeExternMethodCallStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        methodName = ctx.iden().Iden().getText()
        methodArgs = ""
        if ctx.rvalueList():
            params = ctx.rvalueList().rvalue()
            for param in params:
                paramExpr = self.getFStarExpression(param.expr(), symbols, scope, isMethod=True)
                methodArgs += " (" + paramExpr + ")"
        otherContractInstanceName = self.getFStarExpressionLvalue(ctx.otherContractInstance, symbols, scope)
        if " " in otherContractInstanceName:
            otherContractInstanceName = "(" + otherContractInstanceName + ")"

        contractType = ""
        for symbol in symbols:
            if symbol.name == otherContractInstanceName:
                contractType = symbol.type
                break
        
        self.writeToFStar("\nlet bst = (get ()).current in")
        for invariant in self.invariantsOfContract[contractType]:
            self.writeToFStar("\nassume (" + invariant + " " + otherContractInstanceName + " bst); // META-ARGUMENT: CONTRACT INVARIANTS ALWAYS HOLD AT CONTRACT BOUNDARIES AND HENCE IS ALWAYS TRUE")
        # self.writeToFStar("\nassume (sender <> " + otherContractInstanceName + "); // " + otherContractInstanceName + " CANNOT BE EQUAL TO sender AND HENCE IS ALWAYS TRUE")
        self.writeToFStar("\nlet _ = " + methodName + " " + otherContractInstanceName + " self 0 tx block" + methodArgs + " in")
        self.writeToFStar("\nlet balance = get_balance self in") # in case the external contract method sends ether to callee

    def writeRevertStatement(self, ctx:CelestialParser.StatementContext):
        revertString = ctx.StringLiteral().getText()
        self.writeToFStar("\nrevert " + revertString + ";")

    def writeReturnStatement(self, ctx:CelestialParser.ReturnStatementContext, symbols, scope, isVoid=True):
        if isVoid:
            self.writeToFStar("\n()")
        else:
            returnExpression = self.getFStarExpression(ctx.expr(), symbols, scope, isMethod=True)
            self.writeToFStar("\n" + returnExpression)

    def writeTransferStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        # val = self.getFStarExpression(ctx.expr(1), symbols, scope, isMethod=True)
        to = self.getFStarExpression(ctx.to, symbols, scope, isMethod=True)
        payloadString = self.getFStarExpression(ctx.amount, symbols, scope, isMethod=True)
        
        if "=" in to or ctx.to.getText() in self.fields:
            self.writeToFStar("\n" + "let x1 = (" + to + ") in")
            to = "x1"
        if "=" in payloadString or ctx.expr(1).getText() in self.fields:
            self.writeToFStar("\n" + "let x2 = (" + payloadString + ") in")
            payloadString = "x2"

        if "," in payloadString:
            payloadString = "(" + payloadString + ")"

        self.writeToFStar("\n" + "let _ = transfer self " + to + " " + payloadString + " in")

        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_balance self in")

    def writeEmitStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):

        # Generate the event payload expressions translated to F* as a tuple
        payloadString = ""
        for payloadExpr in ctx.expr():
            payloadString += self.getFStarExpression(payloadExpr, symbols, scope, isMethod=True)
            if payloadExpr != ctx.expr()[-1]:
                payloadString += ", "

        # If any of the payload expressions are stateful, let bind the payload tuple
        if "=" in payloadString:
            self.writeToFStar("\n" + "let x2 = (" + payloadString + ") in")
            payloadString = "x2"

        elif "," in payloadString:
            payloadString = "(" + payloadString + ")"

        eventName = ctx.event.Iden().getText()
        self.writeToFStar("\n" + "let _ = emit " + self.fieldPrefix + "_" + eventName + " " + payloadString + " in")

        # Retrieve the contract state and balance again since the payloads can be expressions that update the state
        self.writeToFStar("\nlet cs = get_contract self in")
        self.writeToFStar("\nlet balance = get_balance self in")

    def writeAssertStatement(self, ctx:CelestialParser.StatementContext, symbols, scope):
        assertCondition = self.getFStarExpression(ctx.expr(0), symbols, scope, isInvariant=False, isMethod=True, isFunctionCall=False, isIf=False)
        if "=" in assertCondition:
            self.writeToFStar(" let x1 = " + assertCondition + " in\n")
            assertCondition = "x1"
        self.writeToFStar("assert (" + assertCondition + ");\n")

    def defaultValue(self, datatype, symbols):
        """
        ```
        datatype: string 
        symbols:  list of symbol objects

        Returns the default value of the datatype
        ```
        """

        if datatype == "address":
            return "null"
        elif datatype in ("int", "uint", "uint8"):
            return "0"
        elif datatype == "string":
            return "\"\""
        elif datatype == "bool":
            return "false"
        elif datatype in ("bytes20", "bytes32"):
            return "\"\""
        elif datatype == "bytes":
            return "[]"
        elif self.isMapping(datatype):
            valueType = self.getMapValueType(datatype)
            return "M.const (" + self.defaultValue(valueType, symbols) + ")"
        elif self.isArray(datatype):
            arrayType = self.isArrayOf(datatype)
            return "A.create_empty (" + self.defaultValue(arrayType, symbols) + ")"
        elif datatype[0:8] == "inst_map":
            return "M.const false"

        elif datatype in self.enumTypes: # return the first enumValue for that enumType
            for enumVal in list(self.enumValues.keys()):
                if self.enumValues[enumVal] == datatype:
                    return enumVal[:1].upper() + enumVal[1:]
        elif datatype in self.contracts:
            if self.fieldsOfContract[datatype]:
                prefix = str.lower(datatype)
                s = "{"
                for field in self.fieldsOfContract[datatype]:
                    s += prefix + "_" + field[0] + " = " + self.defaultValue(field[1].getText(), symbols) + "; "
                # s += prefix + "_balance = 0;"
                s += "}"
            else:
                s = "()"
            return s 
        else: # struct
            s = "{"
            for symbol in symbols:
                if symbol.isStructField and symbol.fieldOfStruct == datatype:
                    s += self.addPrefix(symbol.name) + " = " + self.defaultValue(symbol.type, symbols) + "; "
            s += "}"
            return s

    def writeToFStar(self, code):
        #TODO: Add indentation and newlines here
        self.output.write(code)
