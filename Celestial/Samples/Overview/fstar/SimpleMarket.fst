(*Code generated by compiler*)

module SimpleMarket

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
open Item
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val simplemarket_eNewItem : string
assume val simplemarket_eItemSold : string

noeq type t_simplemarket = {
  simplemarket_sellerCredits : (m:(M.t address uint lt){M.def_of m == 0});
  simplemarket_itemsToSell : (m:(M.t item_address bool lt){M.def_of m == false /\ ~ (M.contains m null)});
  simplemarket_totalCredits : uint;
}

(* Contract address type, liveness, and field range macros *)

type simplemarket_address = contract t_simplemarket
let simplemarket_live (c:simplemarket_address) (bst:bstate) =
  c `CM.live_in` bst.cmap
  /\ (let cs = CM.sel c bst.cmap in
    (forall (i:item_address). M.contains cs.simplemarket_itemsToSell i ==> i `CM.live_in` bst.cmap /\ i <> c)
  )

(* Field getters for contract SimpleMarket *)

let simplemarket_get_sellerCredits (c:simplemarket_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `simplemarket_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).simplemarket_sellerCredits)
= let simplemarket_inst = get_contract c in
  simplemarket_inst.simplemarket_sellerCredits

let simplemarket_get_itemsToSell (c:simplemarket_address)
: StEth (m:(M.t item_address bool lt){M.def_of m == false /\ ~ (M.contains m null)})
  (fun st -> c `simplemarket_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).simplemarket_itemsToSell)
= let simplemarket_inst = get_contract c in
  simplemarket_inst.simplemarket_itemsToSell

let simplemarket_get_totalCredits (c:simplemarket_address)
: StEth uint
  (fun st -> c `simplemarket_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).simplemarket_totalCredits)
= let simplemarket_inst = get_contract c in
  simplemarket_inst.simplemarket_totalCredits

(* Field setters for contract SimpleMarket *)

let simplemarket_set_sellerCredits (c:simplemarket_address) (_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `simplemarket_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    simplemarket_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with simplemarket_sellerCredits = _sellerCredits }))
= let simplemarket_inst = get_contract c in
  let simplemarket_inst = { simplemarket_inst with simplemarket_sellerCredits = _sellerCredits } in
  set_contract c simplemarket_inst

let simplemarket_set_itemsToSell (c:simplemarket_address) (_itemsToSell:(m:(M.t item_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}))
: StEth unit
  (fun st -> c `simplemarket_live` st.current
              /\ (forall (i:item_address). M.contains _itemsToSell i ==> item_live i st.current /\ i <> c))
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    simplemarket_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with simplemarket_itemsToSell = _itemsToSell }))
= let simplemarket_inst = get_contract c in
  let simplemarket_inst = { simplemarket_inst with simplemarket_itemsToSell = _itemsToSell } in
  set_contract c simplemarket_inst

let simplemarket_set_totalCredits (c:simplemarket_address) (_totalCredits:uint)
: StEth unit
  (fun st -> c `simplemarket_live` st.current
              /\ _totalCredits >= 0 /\ _totalCredits <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    simplemarket_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with simplemarket_totalCredits = _totalCredits }))
= let simplemarket_inst = get_contract c in
  let simplemarket_inst = { simplemarket_inst with simplemarket_totalCredits = _totalCredits } in
  set_contract c simplemarket_inst

let balanceAndSellerCredits (self:simplemarket_address) (bst:bstate{self `simplemarket_live` bst}) : Type0 =
  let simplemarket_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    (simplemarket_balance == cs.simplemarket_totalCredits) /\ (cs.simplemarket_totalCredits >= ((sum_mapping cs.simplemarket_sellerCredits)))

let sell (self:simplemarket_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (price:uint)
: Eth1 address
  (fun bst ->
    simplemarket_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (balanceAndSellerCredits self bst)
  ))
  (fun bst -> False)
  (fun bst0 itemId bst1 ->
    simplemarket_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndSellerCredits self bst1)
      /\ (((M.contains cs1.simplemarket_itemsToSell itemId)))
      /\ (bst0.balances == bst1.balances)
  ))
=
let itemId:address = null in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((
let contract_addr = create_contract ({item_seller = null; item_price = 0; item_market = null; }) in 
let _ = item_constructor contract_addr self 0 tx block self sender price in
let _ = simplemarket_set_itemsToSell self (M.upd cs.simplemarket_itemsToSell contract_addr true) in contract_addr)) in
let itemId = x1 in
let cs = get_contract self in
itemId

let buyReverts (_itemAddress:address) (old_itemsToSell:tuple2 (m:(M.t item_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_address). M.contains (fst old_itemsToSell) k ==> k `CM.live_in` (snd old_itemsToSell).cmap}) (old_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0})) (_value:uint) (old_sumCredits:uint)
= ((~ (((M.contains (fst old_itemsToSell) _itemAddress)))) \/ ((_value =!= ((CM.sel _itemAddress (snd old_itemsToSell).cmap).item_price)))) \/ (((_value + old_sumCredits) > uint_max))

let buy (self:simplemarket_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (itemId:address)
: Eth1 address
  (fun bst ->
    simplemarket_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (balanceAndSellerCredits self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((buyReverts itemId (cs.simplemarket_itemsToSell, bst) cs.simplemarket_sellerCredits value cs.simplemarket_totalCredits))
  )
  (fun bst0 seller bst1 ->
    simplemarket_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndSellerCredits self bst1)
      /\ ((((~ (((M.contains cs1.simplemarket_itemsToSell itemId)))) /\ (M.equal cs1.simplemarket_sellerCredits (
                let x1 = (cs0.simplemarket_sellerCredits) in
                let x2 = (seller) in
                let x3 = (((M.sel cs0.simplemarket_sellerCredits seller) + value)) in
                let x1 = (M.upd x1 x2 x3) in
                x1))) /\ (l1 == ((mk_event null simplemarket_eItemSold (sender, itemId))::l0))))
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let seller:address = null in
let cs = get_contract self in
let balance = get_balance self in
let item:item_address = (
if M.contains cs.simplemarket_itemsToSell itemId then itemId else null) in
let x1 = (item = null) in
let seller = (if x1 then begin
revert "No such item";
seller end
else seller) in
let cs = get_contract self in
let balance = get_balance self in
let iPrice:uint = (0) in
let bst = (get ()).current in
let x1 = getPrice item self 0 tx block in
let iPrice = x1 in
let balance = get_balance self in
let seller = (if (value <> iPrice) then begin
revert "Incorrect price";
seller end
else seller) in
let cs = get_contract self in
let balance = get_balance self in
let bst = (get ()).current in
let x1 = getSeller item self 0 tx block in
let seller = x1 in
let balance = get_balance self in
let x1 = ((if cs.simplemarket_totalCredits <= uint_max - value then (cs.simplemarket_totalCredits + value) else revert "Overflow error")) in
let _ = simplemarket_set_totalCredits self x1 in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.simplemarket_sellerCredits seller) value)) in
let sellerCredits = cs.simplemarket_sellerCredits in
let _ = simplemarket_set_sellerCredits self (M.upd sellerCredits seller x1) in
let cs = get_contract self in
let _ = simplemarket_set_itemsToSell self (M.delete cs.simplemarket_itemsToSell itemId) in
let cs = get_contract self in
let _ = emit simplemarket_eItemSold (sender, itemId) in
let cs = get_contract self in
let balance = get_balance self in
seller

let withdraw (self:simplemarket_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (amount:uint)
: Eth1 unit
  (fun bst ->
    simplemarket_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (balanceAndSellerCredits self bst)
      /\ (self =!= sender)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((M.sel cs.simplemarket_sellerCredits sender) < amount)
  )
  (fun bst0 x bst1 ->
    simplemarket_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndSellerCredits self bst1)
      /\ ((((M.equal cs1.simplemarket_sellerCredits (
                  let x1 = (cs0.simplemarket_sellerCredits) in
                  let x2 = (sender) in
                  let x3 = ((M.sel cs0.simplemarket_sellerCredits sender) - amount) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1))) /\ (cs1.simplemarket_totalCredits == (cs0.simplemarket_totalCredits - amount))) /\ (b1 == (b0 - amount)))
      /\ (b1 <= b0)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((M.sel cs.simplemarket_sellerCredits sender) >= amount) in
let _ = (if x1 then begin
let _ = transfer self sender amount in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((_sub (M.sel cs.simplemarket_sellerCredits sender) amount)) in
let sellerCredits = cs.simplemarket_sellerCredits in
let _ = simplemarket_set_sellerCredits self (M.upd sellerCredits sender x1) in
let cs = get_contract self in
let _ = simplemarket_set_totalCredits self (_sub cs.simplemarket_totalCredits amount) in
let cs = get_contract self in
() end
else begin
revert "Insufficient balance";
() end) in
let cs = get_contract self in
let balance = get_contract self in
()