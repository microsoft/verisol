(*Code generated by compiler*)

module Item

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array


noeq type t_item = {
  item_seller : address;
  item_price : uint;
  item_market : address;
}

(* Contract address type, liveness, and field range macros *)

type item_address = contract t_item
let item_live (c:item_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract Item *)

let item_get_seller (c:item_address)
: StEth address
  (fun st -> c `item_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_seller)
= let item_inst = get_contract c in
  item_inst.item_seller

let item_get_price (c:item_address)
: StEth uint
  (fun st -> c `item_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_price)
= let item_inst = get_contract c in
  item_inst.item_price

let item_get_market (c:item_address)
: StEth address
  (fun st -> c `item_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_market)
= let item_inst = get_contract c in
  item_inst.item_market

(* Field setters for contract Item *)

let item_set_seller (c:item_address) (_seller:address)
: StEth unit
  (fun st -> c `item_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_seller = _seller }))
= let item_inst = get_contract c in
  let item_inst = { item_inst with item_seller = _seller } in
  set_contract c item_inst

let item_set_price (c:item_address) (_price:uint)
: StEth unit
  (fun st -> c `item_live` st.current
              /\ _price >= 0 /\ _price <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_price = _price }))
= let item_inst = get_contract c in
  let item_inst = { item_inst with item_price = _price } in
  set_contract c item_inst

let item_set_market (c:item_address) (_market:address)
: StEth unit
  (fun st -> c `item_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_market = _market }))
= let item_inst = get_contract c in
  let item_inst = { item_inst with item_market = _market } in
  set_contract c item_inst

let item_constructor (self:item_address) (sender:address) (value:uint) (tx:tx) (block:block) (_s:address) (_m:address) (_p:uint)
: Eth1 unit
  (fun bst -> 
    item_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.item_seller == null)
      /\ (cs.item_price == 0)
      /\ (cs.item_market == null)
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    item_live self bst1 /\ (
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = item_set_seller self _s in
let cs = get_contract self in
let _ = item_set_price self _p in
let cs = get_contract self in
let _ = item_set_market self _m in
let cs = get_contract self in
()

let getSeller (self:item_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 address
  (fun bst ->
    item_live self bst
  )
  (fun bst -> False)
  (fun bst0 s bst1 ->
    item_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((s == cs0.item_seller))
      /\ (bst0.balances == bst1.balances)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let s:address = null in
let cs = get_contract self in
let balance = get_balance self in
cs.item_seller

let getPrice (self:item_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 uint
  (fun bst ->
    item_live self bst
  )
  (fun bst -> False)
  (fun bst0 ret bst1 ->
    item_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((ret == cs0.item_price))
      /\ (bst0.balances == bst1.balances)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let ret:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
cs.item_price