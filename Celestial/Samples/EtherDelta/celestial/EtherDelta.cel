pragma solidity^0.6.8;

import {Safe_Arith} from "./Safe_Arith.sol";
import {Call} from "./Call.sol" ;

contract EtherDelta_Cel
{
    address admin;      //the admin address
    address feeAccount; //the account that will receive fees
    address accountLevelsAddr;
    uint feeMake;       //percentage times (1 ether)
    uint feeTake;       //percentage times (1 ether)
    uint feeRebate;     //percentage times (1 ether)
    mapping (address => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)
    mapping (address => mapping (bytes32 => bool)) orders;
    mapping (address => mapping (bytes32 => uint)) orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)
    event Deposit(address, address, uint, uint);
    event Withdraw(address, address, uint, uint);
    event Order(address, uint, address, uint, uint, uint, address);
    event Cancel(address, uint, address, uint, uint, uint, address, uint8, bytes32, bytes32);
    event Trade(address, uint, address, uint, address, address);

    uint totalBalance;
    bool _lock_;

    using Call for address;

    invariant eth_balances2 {
        balance == totalBalance
    }

    invariant eth_balances {
        totalBalance >= sum_mapping(tokens[null])
    }

    constructor (address admin_, address feeAccount_, uint feeMake_, uint feeTake_, uint feeRebate_) 
        pre (balance == 0)
    {
        admin = admin_;
        feeAccount = feeAccount_;
        feeMake = feeMake_;
        feeTake = feeTake_;
        feeRebate = feeRebate_;
        return;
    }

    fallback () {
        revert ("");
        return;
    }

    function changeAdmin (address admin_) public
        post (new(admin) == admin_)
        tx_reverts (sender != admin)
        r_reverts _lock_
        modifies [admin]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (sender != admin) 
        {
            revert ("");
        }

        admin = admin_;
        return;
    }

    function changeFeeAccount (address feeAccount_) public
        tx_reverts (sender != admin)
        r_reverts _lock_
        modifies [feeAccount]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (sender != admin) 
        {
            revert ("");
        }

        feeAccount = feeAccount_;
        return;
    }

    function changeFeeMake (uint feeMake_) public
        post new(feeMake) == feeMake_
        tx_reverts (sender != admin || feeMake_ > feeMake) 
        r_reverts _lock_
        modifies [feeMake]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (sender != admin || feeMake_ > feeMake) 
        {
            revert ("");
        }

        feeMake = feeMake_;
        return;
    }

    function changeFeeTake (uint feeTake_) public
        post new(feeTake) == feeTake_
        tx_reverts (sender != admin || feeTake_ > feeTake || feeTake_ < feeRebate) 
        r_reverts _lock_
        modifies [feeTake]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (sender != admin || feeTake_ > feeTake || feeTake_ < feeRebate) {
            revert ("");
        }

        feeTake = feeTake_;
        return;
    }

    function changeFeeRebate (uint feeRebate_) public
        post new(feeRebate) == feeRebate_
        tx_reverts (sender != admin || feeRebate_ < feeRebate || feeRebate_ > feeTake)
        r_reverts _lock_
        modifies [feeRebate]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (sender != admin || feeRebate_ < feeRebate || feeRebate_ > feeTake) 
        {
            revert("invalid");
        }

        feeRebate = feeRebate_;
        return;
    }

    function deposit () public
        post (new(tokens) == tokens[null => tokens[null][sender => (tokens[null][sender] + value)]])
             && (new(totalBalance) == totalBalance + value)
        credit
        tx_reverts (totalBalance + value > uint_max)
        r_reverts _lock_
        modifies [tokens, totalBalance, log]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        totalBalance = safe_add(totalBalance, value);
        tokens[null][sender] = tokens[null][sender] + value;
        emit Deposit (null, sender, value, tokens[null][sender]);
        return;
    }

    function withdraw (uint amount) public
        post (new(tokens) == tokens[null => tokens[null][sender => tokens[null][sender] - amount]])
             && new(log) == (Withdraw, null, sender, amount, new(tokens)[null][sender])::(sender, eTransfer, amount)::log
        debit
        tx_reverts (tokens[null][sender] < amount) 
        r_reverts _lock_
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (tokens[null][sender] < amount) 
        {
            revert ("Insufficient balance");
        }

        sender.transfer(amount);
        if (balance == totalBalance)
        {
            revert ("Ether sent to self");
        }

        tokens[null][sender] = tokens[null][sender] - amount;
        totalBalance = totalBalance - amount;
        emit Withdraw (null, sender, amount, tokens[null][sender]);
        return;
    }

    function depositToken (address token, uint amount) public
        post new(tokens) == tokens[token => tokens[token][sender => tokens[token][sender] + amount]]
        tx_reverts token == null || tokens[token][sender] + amount > uint_max
        r_reverts _lock_
        modifies [tokens, totalBalance, balance, log, _lock_]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        if (token == null || amount > uint_max - tokens[token][sender])
        {
            revert ("Invalid token type or overflow");
        }

        _lock_ = true;
        bool tokenTxStatus = token.call_bool(abi.encodeWithSignature("transferFrom(address,address,uint)", sender, address(this), amount));
        _lock_ = false;
        if (tokenTxStatus == false)
        {
            revert ("");
        }

        // The .call may have increased our balance
        if (totalBalance != balance)
        {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = balance;
        
        tokens[token][sender] = tokens[token][sender] + amount;
        emit Deposit (token, sender, amount, tokens[token][sender]);
        return;
    }

    function withdrawToken (address token, uint amount) 
        post (new(tokens) == tokens[token => tokens[token][sender => tokens[token][sender] - amount]])
        tx_reverts token == null || tokens[token][sender] < amount
        r_reverts _lock_
        modifies[tokens, totalBalance, balance, log, _lock_]
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }

        if (token == null || tokens[token][sender] < amount)
        {
            revert ("Invalid token type or overflow");
        }

        _lock_ = true;
        bool tokenTxStatus = token.call_bool(abi.encodeWithSignature("transfer(address,uint)", sender, amount));
        _lock_ = false;
        if (tokenTxStatus == false)
        {
            revert ("");
        }

        // The .call may have increased our balance
        if (totalBalance != balance)
        {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = balance;

        tokens[token][sender] = tokens[token][sender] - amount;
        emit Withdraw (sender, token, amount, tokens[token][sender]);
        return;
    }

    function balanceOf (address token, address user)
        r_reverts _lock_
        returns (uint)
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        return tokens[token][user];
    }

    function order (address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce)
        r_reverts _lock_
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        bytes32 hash = sha256 (abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));
        orders[sender][hash] = true;
        emit Order (tokenGet, amountGet, tokenGive, amountGive, expires, nonce, sender);
        return;
    }

    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s)
        r_reverts _lock_
        modifies []
        returns (uint ret)
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        uint available1;
        uint available2;
        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));
        if (!(
            (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)), v, r, s) == user)
            && block.number <= expires
        )) {
            ret = 0;
        }
        else 
        {
            if (amountGive == 0) revert ("Divide by 0");
            available1 = safe_sub(amountGet, orderFills[user][hash]);
            available2 = safe_mul(tokens[tokenGive][user], amountGet) / amountGive;
            if (available1<available2) ret = available1;
            else ret = available2;
        }
        return ret;
    }

    function testTrade (address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address _sender)
        r_reverts _lock_
        modifies []
        returns (bool ret)
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        uint availableVol = availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s);
        if (!(
            tokens[tokenGet][_sender] >= amount
            && availableVol >= amount
        )) ret = false;
        else ret = true;
        return ret;
    }


    function amountFilled (address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s)
        r_reverts _lock_
        returns (uint)
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));
        return orderFills[user][hash];
    }

    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) 
        r_reverts _lock_
    {
        if (_lock_)
        {
            revert ("Reentrancy detected");
        }
        bytes32 hash = sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));
        if (!(orders[sender][hash] || ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)),v,r,s) == sender)) revert ("");
        orderFills[sender][hash] = amountGet;
        emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, sender, v, r, s);
        return;
    }

}