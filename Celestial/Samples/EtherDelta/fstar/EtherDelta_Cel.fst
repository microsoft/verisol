(*Code generated by compiler*)

module EtherDelta_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val etherdelta_cel_Deposit : string
assume val etherdelta_cel_Withdraw : string
assume val etherdelta_cel_Order : string
assume val etherdelta_cel_Cancel : string
assume val etherdelta_cel_Trade : string

noeq type t_etherdelta_cel = {
  etherdelta_cel_admin : address;
  etherdelta_cel_feeAccount : address;
  etherdelta_cel_accountLevelsAddr : address;
  etherdelta_cel_feeMake : uint;
  etherdelta_cel_feeTake : uint;
  etherdelta_cel_feeRebate : uint;
  etherdelta_cel_tokens : (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)});
  etherdelta_cel_orders : (m:(M.t address (m:(M.t bytes32 bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)});
  etherdelta_cel_orderFills : (m:(M.t address (m:(M.t bytes32 uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)});
  etherdelta_cel_totalBalance : uint;
  etherdelta_cel__lock_ : bool;
}

(* Contract address type, liveness, and field range macros *)

type etherdelta_cel_address = contract t_etherdelta_cel
let etherdelta_cel_live (c:etherdelta_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract EtherDelta_Cel *)

let etherdelta_cel_get_admin (c:etherdelta_cel_address)
: StEth address
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_admin)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_admin

let etherdelta_cel_get_feeAccount (c:etherdelta_cel_address)
: StEth address
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_feeAccount)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_feeAccount

let etherdelta_cel_get_accountLevelsAddr (c:etherdelta_cel_address)
: StEth address
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_accountLevelsAddr)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_accountLevelsAddr

let etherdelta_cel_get_feeMake (c:etherdelta_cel_address)
: StEth uint
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_feeMake)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_feeMake

let etherdelta_cel_get_feeTake (c:etherdelta_cel_address)
: StEth uint
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_feeTake)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_feeTake

let etherdelta_cel_get_feeRebate (c:etherdelta_cel_address)
: StEth uint
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_feeRebate)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_feeRebate

let etherdelta_cel_get_tokens (c:etherdelta_cel_address)
: StEth (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_tokens)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_tokens

let etherdelta_cel_get_orders (c:etherdelta_cel_address)
: StEth (m:(M.t address (m:(M.t bytes32 bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)})
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_orders)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_orders

let etherdelta_cel_get_orderFills (c:etherdelta_cel_address)
: StEth (m:(M.t address (m:(M.t bytes32 uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_orderFills)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_orderFills

let etherdelta_cel_get_totalBalance (c:etherdelta_cel_address)
: StEth uint
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel_totalBalance)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel_totalBalance

let etherdelta_cel_get__lock_ (c:etherdelta_cel_address)
: StEth bool
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).etherdelta_cel__lock_)
= let etherdelta_cel_inst = get_contract c in
  etherdelta_cel_inst.etherdelta_cel__lock_

(* Field setters for contract EtherDelta_Cel *)

let etherdelta_cel_set_admin (c:etherdelta_cel_address) (_admin:address)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_admin = _admin }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_admin = _admin } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_feeAccount (c:etherdelta_cel_address) (_feeAccount:address)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_feeAccount = _feeAccount }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_feeAccount = _feeAccount } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_accountLevelsAddr (c:etherdelta_cel_address) (_accountLevelsAddr:address)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_accountLevelsAddr = _accountLevelsAddr }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_accountLevelsAddr = _accountLevelsAddr } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_feeMake (c:etherdelta_cel_address) (_feeMake:uint)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current
              /\ _feeMake >= 0 /\ _feeMake <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_feeMake = _feeMake }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_feeMake = _feeMake } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_feeTake (c:etherdelta_cel_address) (_feeTake:uint)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current
              /\ _feeTake >= 0 /\ _feeTake <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_feeTake = _feeTake }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_feeTake = _feeTake } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_feeRebate (c:etherdelta_cel_address) (_feeRebate:uint)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current
              /\ _feeRebate >= 0 /\ _feeRebate <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_feeRebate = _feeRebate }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_feeRebate = _feeRebate } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_tokens (c:etherdelta_cel_address) (_tokens:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)}))
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_tokens = _tokens }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_tokens = _tokens } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_orders (c:etherdelta_cel_address) (_orders:(m:(M.t address (m:(M.t bytes32 bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)}))
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_orders = _orders }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_orders = _orders } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_orderFills (c:etherdelta_cel_address) (_orderFills:(m:(M.t address (m:(M.t bytes32 uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)}))
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_orderFills = _orderFills }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_orderFills = _orderFills } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set_totalBalance (c:etherdelta_cel_address) (_totalBalance:uint)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current
              /\ _totalBalance >= 0 /\ _totalBalance <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel_totalBalance = _totalBalance }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel_totalBalance = _totalBalance } in
  set_contract c etherdelta_cel_inst

let etherdelta_cel_set__lock_ (c:etherdelta_cel_address) (__lock_:bool)
: StEth unit
  (fun st -> c `etherdelta_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    etherdelta_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with etherdelta_cel__lock_ = __lock_ }))
= let etherdelta_cel_inst = get_contract c in
  let etherdelta_cel_inst = { etherdelta_cel_inst with etherdelta_cel__lock_ = __lock_ } in
  set_contract c etherdelta_cel_inst

let eth_balances2 (self:etherdelta_cel_address) (bst:bstate{self `etherdelta_cel_live` bst}) : Type0 =
  let etherdelta_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    etherdelta_cel_balance == cs.etherdelta_cel_totalBalance

let eth_balances (self:etherdelta_cel_address) (bst:bstate{self `etherdelta_cel_live` bst}) : Type0 =
  let etherdelta_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.etherdelta_cel_totalBalance >= ((sum_mapping (M.sel cs.etherdelta_cel_tokens null)))

let etherdelta_cel_constructor (self:etherdelta_cel_address) (sender:address) (value:uint) (tx:tx) (block:block) (admin_:address) (feeAccount_:address) (feeMake_:uint) (feeTake_:uint) (feeRebate_:uint)
: Eth1 unit
  (fun bst -> 
    etherdelta_cel_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.etherdelta_cel_admin == null)
      /\ (cs.etherdelta_cel_feeAccount == null)
      /\ (cs.etherdelta_cel_accountLevelsAddr == null)
      /\ (cs.etherdelta_cel_feeMake == 0)
      /\ (cs.etherdelta_cel_feeTake == 0)
      /\ (cs.etherdelta_cel_feeRebate == 0)
      /\ (cs.etherdelta_cel_tokens == M.const (M.const (0)))
      /\ (cs.etherdelta_cel_orders == M.const (M.const (false)))
      /\ (cs.etherdelta_cel_orderFills == M.const (M.const (0)))
      /\ (cs.etherdelta_cel_totalBalance == 0)
      /\ (cs.etherdelta_cel__lock_ == false)
      /\ ((b == 0))
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
    /\ (eth_balances2 self bst1)
    /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_admin self admin_ in
let cs = get_contract self in
let _ = etherdelta_cel_set_feeAccount self feeAccount_ in
let cs = get_contract self in
let _ = etherdelta_cel_set_feeMake self feeMake_ in
let cs = get_contract self in
let _ = etherdelta_cel_set_feeTake self feeTake_ in
let cs = get_contract self in
let _ = etherdelta_cel_set_feeRebate self feeRebate_ in
let cs = get_contract self in
()

let fallback (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
     /\ (eth_balances2 self bst1)
     /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
revert "";
()

let changeAdmin (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (admin_:address)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((sender =!= cs.etherdelta_cel_admin))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ ((cs1.etherdelta_cel_admin == admin_))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_totalBalance == cs1.etherdelta_cel_totalBalance)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_tokens == cs1.etherdelta_cel_tokens)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.etherdelta_cel_admin) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_admin self admin_ in
let cs = get_contract self in
()

let changeFeeAccount (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (feeAccount_:address)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((sender =!= cs.etherdelta_cel_admin))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_totalBalance == cs1.etherdelta_cel_totalBalance)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_tokens == cs1.etherdelta_cel_tokens)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.etherdelta_cel_admin) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_feeAccount self feeAccount_ in
let cs = get_contract self in
()

let changeFeeMake (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (feeMake_:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((sender =!= cs.etherdelta_cel_admin) \/ (feeMake_ > cs.etherdelta_cel_feeMake)))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (cs1.etherdelta_cel_feeMake == feeMake_)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_totalBalance == cs1.etherdelta_cel_totalBalance)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_tokens == cs1.etherdelta_cel_tokens)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((sender <> cs.etherdelta_cel_admin) || (feeMake_ > cs.etherdelta_cel_feeMake)) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_feeMake self feeMake_ in
let cs = get_contract self in
()

let changeFeeTake (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (feeTake_:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((sender =!= cs.etherdelta_cel_admin) \/ (feeTake_ > cs.etherdelta_cel_feeTake)) \/ (feeTake_ < cs.etherdelta_cel_feeRebate)))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (cs1.etherdelta_cel_feeTake == feeTake_)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_totalBalance == cs1.etherdelta_cel_totalBalance)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_tokens == cs1.etherdelta_cel_tokens)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (((sender <> cs.etherdelta_cel_admin) || (feeTake_ > cs.etherdelta_cel_feeTake)) || (feeTake_ < cs.etherdelta_cel_feeRebate)) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_feeTake self feeTake_ in
let cs = get_contract self in
()

let changeFeeRebate (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (feeRebate_:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((sender =!= cs.etherdelta_cel_admin) \/ (feeRebate_ < cs.etherdelta_cel_feeRebate)) \/ (feeRebate_ > cs.etherdelta_cel_feeTake)))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (cs1.etherdelta_cel_feeRebate == feeRebate_)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_totalBalance == cs1.etherdelta_cel_totalBalance)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_tokens == cs1.etherdelta_cel_tokens)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (((sender <> cs.etherdelta_cel_admin) || (feeRebate_ < cs.etherdelta_cel_feeRebate)) || (feeRebate_ > cs.etherdelta_cel_feeTake)) then begin
revert "invalid";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set_feeRebate self feeRebate_ in
let cs = get_contract self in
()

let deposit (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.etherdelta_cel_totalBalance + value) > uint_max))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (((M.equal cs1.etherdelta_cel_tokens (
      let x1 = (cs0.etherdelta_cel_tokens) in
      let x2 = (null) in
      let x3 = (
        let x1 = (M.sel cs0.etherdelta_cel_tokens null) in
        let x2 = (sender) in
        let x3 = (((M.sel (M.sel cs0.etherdelta_cel_tokens null) sender) + value)) in
        let x1 = (M.upd x1 x2 x3) in
        x1) in
      let x1 = (M.upd x1 x2 x3) in
      x1))) /\ ((cs1.etherdelta_cel_totalBalance == (cs0.etherdelta_cel_totalBalance + value))))
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel__lock_ == cs1.etherdelta_cel__lock_)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if cs.etherdelta_cel_totalBalance <= uint_max - value then (cs.etherdelta_cel_totalBalance + value) else revert "Overflow error")) in
let _ = etherdelta_cel_set_totalBalance self x1 in
let cs = get_contract self in
let x5 = ((_add (M.sel (M.sel cs.etherdelta_cel_tokens null) sender) value)) in
let x4 = cs.etherdelta_cel_tokens in

let x3 = (null) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in

let _ = etherdelta_cel_set_tokens self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Deposit (null, sender, value, M.sel (M.sel cs.etherdelta_cel_tokens null) sender) in
let cs = get_contract self in
let balance = get_balance self in
()

let withdraw (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (amount:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((M.sel (M.sel cs.etherdelta_cel_tokens null) sender) < amount))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (((M.equal cs1.etherdelta_cel_tokens (
      let x1 = (cs0.etherdelta_cel_tokens) in
      let x2 = (null) in
      let x3 = (
        let x1 = (M.sel cs0.etherdelta_cel_tokens null) in
        let x2 = (sender) in
        let x3 = ((M.sel (M.sel cs0.etherdelta_cel_tokens null) sender) - amount) in
        let x1 = (M.upd x1 x2 x3) in
        x1) in
      let x1 = (M.upd x1 x2 x3) in
      x1))) /\ (l1 == ((mk_event null etherdelta_cel_Withdraw (null, sender, amount, M.sel (M.sel cs1.etherdelta_cel_tokens null) sender))::(mk_event sender eTransfer amount)::l0)))
      /\ (b1 <= b0)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((M.sel (M.sel cs.etherdelta_cel_tokens null) sender) < amount) then begin
revert "Insufficient balance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = transfer self sender amount in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (balance = cs.etherdelta_cel_totalBalance) in
let _ = (if x1 then begin
revert "Ether sent to self";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x5 = ((_sub (M.sel (M.sel cs.etherdelta_cel_tokens null) sender) amount)) in
let x4 = cs.etherdelta_cel_tokens in

let x3 = (null) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
  
let _ = etherdelta_cel_set_tokens self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = etherdelta_cel_set_totalBalance self (_sub cs.etherdelta_cel_totalBalance amount) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Withdraw (null, sender, amount, M.sel (M.sel cs.etherdelta_cel_tokens null) sender) in
let cs = get_contract self in
let balance = get_balance self in
()

let depositToken (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (token:address) (amount:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((token == null) \/ (((M.sel (M.sel cs.etherdelta_cel_tokens token) sender) + amount) > uint_max))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (M.equal cs1.etherdelta_cel_tokens (
      let x1 = (cs0.etherdelta_cel_tokens) in
      let x2 = (token) in
      let x3 = (
        let x1 = (M.sel cs0.etherdelta_cel_tokens token) in
        let x2 = (sender) in
        let x3 = ((M.sel (M.sel cs0.etherdelta_cel_tokens token) sender) + amount) in
        let x1 = (M.upd x1 x2 x3) in
        x1) in
      let x1 = (M.upd x1 x2 x3) in
      x1))
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((token = null) || (amount > ((_sub uint_max (M.sel (M.sel cs.etherdelta_cel_tokens token) sender))))) in
let _ = (if x1 then begin
revert "Invalid token type or overflow";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set__lock_ self true in
let cs = get_contract self in
assert ((cs.etherdelta_cel__lock_));
let tokenTxStatus:bool = call_bool self ((abi_encodeWithSignature("transferFrom(address,address,uint)", sender, self, amount))) in
let balance = get_balance self in
let _ = etherdelta_cel_set__lock_ self false in
let cs = get_contract self in
let x1 = (tokenTxStatus = false) in
let _ = (if x1 then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel_totalBalance <> balance) then begin
revert "Unexpected Ether transferred to self";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (balance) in
let _ = etherdelta_cel_set_totalBalance self x1 in
let cs = get_contract self in
let x5 = ((_add (M.sel (M.sel cs.etherdelta_cel_tokens token) sender) amount)) in
let x4 = cs.etherdelta_cel_tokens in

let x3 = (token) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
  
let _ = etherdelta_cel_set_tokens self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Deposit (token, sender, amount, M.sel (M.sel cs.etherdelta_cel_tokens token) sender) in
let cs = get_contract self in
let balance = get_balance self in
()

let withdrawToken (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (token:address) (amount:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((token == null) \/ ((M.sel (M.sel cs.etherdelta_cel_tokens token) sender) < amount))
    \/ (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ ((M.equal cs1.etherdelta_cel_tokens (
      let x1 = (cs0.etherdelta_cel_tokens) in
      let x2 = (token) in
      let x3 = (
        let x1 = (M.sel cs0.etherdelta_cel_tokens token) in
        let x2 = (sender) in
        let x3 = ((M.sel (M.sel cs0.etherdelta_cel_tokens token) sender) - amount) in
        let x1 = (M.upd x1 x2 x3) in
        x1) in
      let x1 = (M.upd x1 x2 x3) in
      x1)))
      /\ (cs0.etherdelta_cel_feeAccount == cs1.etherdelta_cel_feeAccount)
      /\ (cs0.etherdelta_cel_accountLevelsAddr == cs1.etherdelta_cel_accountLevelsAddr)
      /\ (cs0.etherdelta_cel_feeRebate == cs1.etherdelta_cel_feeRebate)
      /\ (cs0.etherdelta_cel_feeMake == cs1.etherdelta_cel_feeMake)
      /\ (cs0.etherdelta_cel_feeTake == cs1.etherdelta_cel_feeTake)
      /\ (cs0.etherdelta_cel_orders == cs1.etherdelta_cel_orders)
      /\ (cs0.etherdelta_cel_admin == cs1.etherdelta_cel_admin)
      /\ (cs0.etherdelta_cel_orderFills == cs1.etherdelta_cel_orderFills)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((token = null) || ((M.sel (M.sel cs.etherdelta_cel_tokens token) sender) < amount)) in
let _ = (if x1 then begin
revert "Invalid token type or overflow";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = etherdelta_cel_set__lock_ self true in
let cs = get_contract self in
assert ((cs.etherdelta_cel__lock_));
let tokenTxStatus:bool = call_bool self ((abi_encodeWithSignature("transfer(address,uint)", sender, amount))) in
let balance = get_balance self in
let _ = etherdelta_cel_set__lock_ self false in
let cs = get_contract self in
let x1 = (tokenTxStatus = false) in
let _ = (if x1 then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel_totalBalance <> balance) then begin
revert "Unexpected Ether transferred to self";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (balance) in
let _ = etherdelta_cel_set_totalBalance self x1 in
let cs = get_contract self in
let x5 = ((_sub (M.sel (M.sel cs.etherdelta_cel_tokens token) sender) amount)) in
let x4 = cs.etherdelta_cel_tokens in

let x3 = (token) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
  
let _ = etherdelta_cel_set_tokens self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Withdraw (sender, token, amount, M.sel (M.sel cs.etherdelta_cel_tokens token) sender) in
let cs = get_contract self in
let balance = get_balance self in
()

let balanceOf (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (token:address) (user:address)
: Eth1 uint
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
     /\ (eth_balances2 self bst1)
     /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
M.sel (M.sel cs.etherdelta_cel_tokens token) user

let order (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (tokenGet:address) (amountGet:uint) (tokenGive:address) (amountGive:uint) (expires:uint) (nonce:uint)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
     /\ (eth_balances2 self bst1)
     /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let hash:bytes32 = ((sha256 ((abi_encodePacked(self, tokenGet, amountGet, tokenGive, amountGive, expires, nonce))))) in
let x5 = (true) in
let x4 = cs.etherdelta_cel_orders in

let x3 = (sender) in
let x2 = (M.sel x4 x3) in
let x1 = (hash) in
let x0 = (M.sel x2 x1) in
  
let _ = etherdelta_cel_set_orders self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Order (tokenGet, amountGet, tokenGive, amountGive, expires, nonce, sender) in
let cs = get_contract self in
let balance = get_balance self in
()

let availableVolume (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (tokenGet:address) (amountGet:uint) (tokenGive:address) (amountGive:uint) (expires:uint) (nonce:uint) (user:address) (v:uint8) (r:bytes32) (s:bytes32)
: Eth1 uint
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 ret bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let ret:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
let ret = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
ret end
else ret) in
let cs = get_contract self in
let balance = get_balance self in
let available1:uint = (0) in
let available2:uint = (0) in
let hash:bytes32 = ((sha256 ((abi_encodePacked(self, tokenGet, amountGet, tokenGive, amountGive, expires, nonce))))) in
let x1 = (op_Negation (((((M.sel (M.sel cs.etherdelta_cel_orders user) hash) || (((ecrecover ((keccak256 ((abi_encodePacked(("\x19Ethereum Signed Message:\n32"), hash))))) v r s)) = user))) && (block.number <= expires)))) in
let ret = (if x1 then begin
let ret = 0 in
let cs = get_contract self in
ret end
else begin
let x1 = (amountGive = 0) in
let ret = (if x1 then begin
revert "Divide by 0";
ret end
else ret) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if (M.sel (M.sel cs.etherdelta_cel_orderFills user) hash) <= amountGet then (amountGet - (M.sel (M.sel cs.etherdelta_cel_orderFills user) hash)) else revert "Underflow error")) in
let available1 = x1 in
let cs = get_contract self in
let available2 = (_div ((safe_mul (M.sel (M.sel cs.etherdelta_cel_tokens tokenGive) user) amountGet)) amountGive) in
let cs = get_contract self in
let ret = (if (available1 < available2) then begin
let ret = available1 in
let cs = get_contract self in
ret end
else begin
let ret = available2 in
let cs = get_contract self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret

let testTrade (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (tokenGet:address) (amountGet:uint) (tokenGive:address) (amountGive:uint) (expires:uint) (nonce:uint) (user:address) (v:uint8) (r:bytes32) (s:bytes32) (amount:uint) (_sender:address)
: Eth1 bool
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 ret bst1 ->
    etherdelta_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (eth_balances2 self bst1)
      /\ (eth_balances self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let ret:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let ret = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
ret end
else ret) in
let cs = get_contract self in
let balance = get_balance self in
let availableVol:uint = ((availableVolume self self 0 tx block tokenGet amountGet tokenGive amountGive expires nonce user v r s)) in
let x1 = (op_Negation ((((M.sel (M.sel cs.etherdelta_cel_tokens tokenGet) _sender) >= amount) && (availableVol >= amount)))) in
let ret = (if x1 then begin
let ret = false in
let cs = get_contract self in
ret end
else begin
let ret = true in
let cs = get_contract self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret

let amountFilled (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (tokenGet:address) (amountGet:uint) (tokenGive:address) (amountGive:uint) (expires:uint) (nonce:uint) (user:address) (v:uint8) (r:bytes32) (s:bytes32)
: Eth1 uint
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
     /\ (eth_balances2 self bst1)
     /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let hash:bytes32 = ((sha256 ((abi_encodePacked(self, tokenGet, amountGet, tokenGive, amountGive, expires, nonce))))) in
M.sel (M.sel cs.etherdelta_cel_orderFills user) hash

let cancelOrder (self:etherdelta_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (tokenGet:address) (amountGet:uint) (tokenGive:address) (amountGive:uint) (expires:uint) (nonce:uint) (v:uint8) (r:bytes32) (s:bytes32)
: Eth1 unit
  (fun bst ->
    etherdelta_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (eth_balances2 self bst)
      /\ (eth_balances self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (cs.etherdelta_cel__lock_)
  )
  (fun bst0 x bst1 ->
    etherdelta_cel_live self bst1
     /\ (eth_balances2 self bst1)
     /\ (eth_balances self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.etherdelta_cel__lock_) then begin
revert "Reentrancy detected";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let hash:bytes32 = ((sha256 ((abi_encodePacked(self, tokenGet, amountGet, tokenGive, amountGive, expires, nonce))))) in
let x1 = (op_Negation (((M.sel (M.sel cs.etherdelta_cel_orders sender) hash) || (((ecrecover ((keccak256 ((abi_encodePacked(("\x19Ethereum Signed Message:\n32"), hash))))) v r s)) = sender)))) in
let _ = (if x1 then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x5 = (amountGet) in
let x4 = cs.etherdelta_cel_orderFills in

let x3 = (sender) in
let x2 = (M.sel x4 x3) in
let x1 = (hash) in
let x0 = (M.sel x2 x1) in
  
let _ = etherdelta_cel_set_orderFills self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit etherdelta_cel_Cancel (tokenGet, amountGet, tokenGive, amountGive, expires, nonce, sender, v, r, s) in
let cs = get_contract self in
let balance = get_balance self in
()