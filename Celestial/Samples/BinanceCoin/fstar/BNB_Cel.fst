(*Code generated by compiler*)

module BNB_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val bnb_cel_Transfer : string
assume val bnb_cel_Burn : string
assume val bnb_cel_Freeze : string
assume val bnb_cel_Unfreeze : string

noeq type t_bnb_cel = {
  bnb_cel_name : string;
  bnb_cel_symbol : string;
  bnb_cel_decimals : uint8;
  bnb_cel_totalSupply : uint;
  bnb_cel_owner : address;
  bnb_cel_balanceOf : (m:(M.t address uint lt){M.def_of m == 0});
  bnb_cel_freezeOf : (m:(M.t address uint lt){M.def_of m == 0});
  bnb_cel_allowance : (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)});
}

(* Contract address type, liveness, and field range macros *)

type bnb_cel_address = contract t_bnb_cel
let bnb_cel_live (c:bnb_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract BNB_Cel *)

let bnb_cel_get_name (c:bnb_cel_address)
: StEth string
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_name)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_name

let bnb_cel_get_symbol (c:bnb_cel_address)
: StEth string
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_symbol)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_symbol

let bnb_cel_get_decimals (c:bnb_cel_address)
: StEth uint8
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_decimals)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_decimals

let bnb_cel_get_totalSupply (c:bnb_cel_address)
: StEth uint
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_totalSupply)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_totalSupply

let bnb_cel_get_owner (c:bnb_cel_address)
: StEth address
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_owner)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_owner

let bnb_cel_get_balanceOf (c:bnb_cel_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_balanceOf)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_balanceOf

let bnb_cel_get_freezeOf (c:bnb_cel_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_freezeOf)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_freezeOf

let bnb_cel_get_allowance (c:bnb_cel_address)
: StEth (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).bnb_cel_allowance)
= let bnb_cel_inst = get_contract c in
  bnb_cel_inst.bnb_cel_allowance

(* Field setters for contract BNB_Cel *)

let bnb_cel_set_name (c:bnb_cel_address) (_name:string)
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_name = _name }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_name = _name } in
  set_contract c bnb_cel_inst

let bnb_cel_set_symbol (c:bnb_cel_address) (_symbol:string)
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_symbol = _symbol }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_symbol = _symbol } in
  set_contract c bnb_cel_inst

let bnb_cel_set_decimals (c:bnb_cel_address) (_decimals:uint8)
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_decimals = _decimals }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_decimals = _decimals } in
  set_contract c bnb_cel_inst

let bnb_cel_set_totalSupply (c:bnb_cel_address) (_totalSupply:uint)
: StEth unit
  (fun st -> c `bnb_cel_live` st.current
              /\ _totalSupply >= 0 /\ _totalSupply <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_totalSupply = _totalSupply }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_totalSupply = _totalSupply } in
  set_contract c bnb_cel_inst

let bnb_cel_set_owner (c:bnb_cel_address) (_owner:address)
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_owner = _owner }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_owner = _owner } in
  set_contract c bnb_cel_inst

let bnb_cel_set_balanceOf (c:bnb_cel_address) (_balanceOf:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_balanceOf = _balanceOf }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_balanceOf = _balanceOf } in
  set_contract c bnb_cel_inst

let bnb_cel_set_freezeOf (c:bnb_cel_address) (_freezeOf:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_freezeOf = _freezeOf }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_freezeOf = _freezeOf } in
  set_contract c bnb_cel_inst

let bnb_cel_set_allowance (c:bnb_cel_address) (_allowance:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)}))
: StEth unit
  (fun st -> c `bnb_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    bnb_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with bnb_cel_allowance = _allowance }))
= let bnb_cel_inst = get_contract c in
  let bnb_cel_inst = { bnb_cel_inst with bnb_cel_allowance = _allowance } in
  set_contract c bnb_cel_inst

let totalSupplyInv (self:bnb_cel_address) (bst:bstate{self `bnb_cel_live` bst}) : Type0 =
  let bnb_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.bnb_cel_totalSupply == (((sum_mapping cs.bnb_cel_balanceOf)) + ((sum_mapping cs.bnb_cel_freezeOf)))

let bnb_cel_constructor (self:bnb_cel_address) (sender:address) (value:uint) (tx:tx) (block:block) (initialSupply:uint) (tokenName:string) (decimalUnits:uint8) (tokenSymbol:string)
: Eth1 unit
  (fun bst -> 
    bnb_cel_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.bnb_cel_name == "")
      /\ (cs.bnb_cel_symbol == "")
      /\ (cs.bnb_cel_decimals == 0)
      /\ (cs.bnb_cel_totalSupply == 0)
      /\ (cs.bnb_cel_owner == null)
      /\ (cs.bnb_cel_balanceOf == M.const (0))
      /\ (cs.bnb_cel_freezeOf == M.const (0))
      /\ (cs.bnb_cel_allowance == M.const (M.const (0)))
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    bnb_cel_live self bst1
    /\ (totalSupplyInv self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf sender initialSupply) in
let cs = get_contract self in
let _ = bnb_cel_set_totalSupply self initialSupply in
let cs = get_contract self in
let _ = bnb_cel_set_name self tokenName in
let cs = get_contract self in
let _ = bnb_cel_set_symbol self tokenSymbol in
let cs = get_contract self in
let _ = bnb_cel_set_decimals self decimalUnits in
let cs = get_contract self in
let _ = bnb_cel_set_owner self sender in
let cs = get_contract self in
()

let _transfer (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_to:address) (_value:uint)
: Eth1 unit
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((_to == null) \/ (_value <= 0)) \/ ((M.sel cs.bnb_cel_balanceOf sender) < _value)) \/ ((M.sel cs.bnb_cel_balanceOf _to) > (uint_max - _value)))
  )
  (fun bst0 x bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ ((l1 == ((mk_event null bnb_cel_Transfer (sender, _to, _value))::l0)) /\ (if (sender <> _to) then
  (M.equal cs1.bnb_cel_balanceOf (
          let x1 = (cs0.bnb_cel_balanceOf) in
          let x2 = (sender) in
          let x3 = ((M.sel cs0.bnb_cel_balanceOf sender) - _value) in
          let x1 = (M.upd x1 x2 x3) in
          let x2 = (_to) in
          let x3 = ((M.sel cs0.bnb_cel_balanceOf _to) + _value) in
          let x1 = (M.upd x1 x2 x3) in
          x1))
else
 (M.equal cs1.bnb_cel_balanceOf (
          let x1 = (cs0.bnb_cel_balanceOf) in
          let x2 = (sender) in
          let x3 = (M.sel cs0.bnb_cel_balanceOf sender) in
          let x1 = (M.upd x1 x2 x3) in
          x1))
))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.bnb_cel_allowance == cs1.bnb_cel_allowance)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_totalSupply == cs1.bnb_cel_totalSupply)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
      /\ (cs0.bnb_cel_freezeOf == cs1.bnb_cel_freezeOf)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_to = null) in
let _ = (if x1 then begin
revert "Preventing transfer to 0x0 address";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let _ = (if x1 then begin
revert "Value is 0";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((M.sel cs.bnb_cel_balanceOf sender) < _value) then begin
revert "Sender doesn't have enough";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((M.sel cs.bnb_cel_balanceOf _to) > ((_sub uint_max _value))) then begin
revert "Overflow!";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if _value <= (M.sel cs.bnb_cel_balanceOf sender) then ((M.sel cs.bnb_cel_balanceOf sender) - _value) else revert "Underflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let x1 = ((if (M.sel cs.bnb_cel_balanceOf _to) <= uint_max - _value then ((M.sel cs.bnb_cel_balanceOf _to) + _value) else revert "Overflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf _to x1) in
let cs = get_contract self in
let _ = emit bnb_cel_Transfer (sender, _to, _value) in
let cs = get_contract self in
let balance = get_balance self in
()

let approve (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_spender:address) (_value:uint)
: Eth1 bool
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (_value <= 0)
  )
  (fun bst0 success bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (M.equal cs1.bnb_cel_allowance (
      let x1 = (cs0.bnb_cel_allowance) in
      let x2 = (sender) in
      let x3 = (
        let x1 = (M.sel cs0.bnb_cel_allowance sender) in
        let x2 = (_spender) in
        let x3 = (_value) in
        let x1 = (M.upd x1 x2 x3) in
        x1) in
      let x1 = (M.upd x1 x2 x3) in
      x1))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_totalSupply == cs1.bnb_cel_totalSupply)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
      /\ (cs0.bnb_cel_freezeOf == cs1.bnb_cel_freezeOf)
      /\ (cs0.bnb_cel_balanceOf == cs1.bnb_cel_balanceOf)
  ))
=
let success:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let success = (if x1 then begin
revert "value leq 0";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x5 = (_value) in
let x4 = cs.bnb_cel_allowance in

let x3 = (sender) in
let x2 = (M.sel x4 x3) in
let x1 = (_spender) in
let x0 = (M.sel x2 x1) in
  
let _ = bnb_cel_set_allowance self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
true

let transferFrom (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_from:address) (_to:address) (_value:uint)
: Eth1 bool
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((((_to == null) \/ (_value <= 0)) \/ ((M.sel cs.bnb_cel_balanceOf _from) < _value)) \/ ((M.sel cs.bnb_cel_balanceOf _to) > (uint_max - _value))) \/ (_value > (M.sel (M.sel cs.bnb_cel_allowance _from) sender)))
  )
  (fun bst0 success bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (((M.equal cs1.bnb_cel_allowance (
          let x1 = (cs0.bnb_cel_allowance) in
          let x2 = (_from) in
          let x3 = (
            let x1 = (M.sel cs0.bnb_cel_allowance _from) in
            let x2 = (sender) in
            let x3 = ((M.sel (M.sel cs0.bnb_cel_allowance _from) sender) - _value) in
            let x1 = (M.upd x1 x2 x3) in
            x1) in
          let x1 = (M.upd x1 x2 x3) in
          x1)) /\ (l1 == ((mk_event null bnb_cel_Transfer (_from, _to, _value))::l0))) /\ (if (_from <> _to) then
  (M.equal cs1.bnb_cel_balanceOf (
            let x1 = (cs0.bnb_cel_balanceOf) in
            let x2 = (_from) in
            let x3 = ((M.sel cs0.bnb_cel_balanceOf _from) - _value) in
            let x1 = (M.upd x1 x2 x3) in
            let x2 = (_to) in
            let x3 = ((M.sel cs0.bnb_cel_balanceOf _to) + _value) in
            let x1 = (M.upd x1 x2 x3) in
            x1))
else
 (M.equal cs1.bnb_cel_balanceOf (
            let x1 = (cs0.bnb_cel_balanceOf) in
            let x2 = (_from) in
            let x3 = (M.sel cs0.bnb_cel_balanceOf _from) in
            let x1 = (M.upd x1 x2 x3) in
            x1))
))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_totalSupply == cs1.bnb_cel_totalSupply)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
      /\ (cs0.bnb_cel_freezeOf == cs1.bnb_cel_freezeOf)
  ))
=
let success:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_to = null) in
let success = (if x1 then begin
revert "preventing transfer to address 0x00";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let success = (if x1 then begin
revert "value leq 0";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let success = (if ((M.sel cs.bnb_cel_balanceOf _from) < _value) then begin
revert "sender doesn't have enough!";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let success = (if ((M.sel cs.bnb_cel_balanceOf _to) > ((_sub uint_max _value))) then begin
revert "Overflow!";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let success = (if (_value > (M.sel (M.sel cs.bnb_cel_allowance _from) sender)) then begin
revert "allowance check failed";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if _value <= (M.sel cs.bnb_cel_balanceOf _from) then ((M.sel cs.bnb_cel_balanceOf _from) - _value) else revert "Underflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf _from x1) in
let cs = get_contract self in
let x1 = ((if (M.sel cs.bnb_cel_balanceOf _to) <= uint_max - _value then ((M.sel cs.bnb_cel_balanceOf _to) + _value) else revert "Overflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf _to x1) in
let cs = get_contract self in
let x5 = ((if _value <= (M.sel (M.sel cs.bnb_cel_allowance _from) sender) then ((M.sel (M.sel cs.bnb_cel_allowance _from) sender) - _value) else revert "Underflow error")) in
let x4 = cs.bnb_cel_allowance in

let x3 = (_from) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
    
let _ = bnb_cel_set_allowance self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit bnb_cel_Transfer (_from, _to, _value) in
let cs = get_contract self in
let balance = get_balance self in
true

let burn (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_value:uint)
: Eth1 bool
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((_value <= 0) \/ ((M.sel cs.bnb_cel_balanceOf sender) < _value)) \/ (cs.bnb_cel_totalSupply < _value))
  )
  (fun bst0 success bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (((M.equal cs1.bnb_cel_balanceOf (
            let x1 = (cs0.bnb_cel_balanceOf) in
            let x2 = (sender) in
            let x3 = ((M.sel cs0.bnb_cel_balanceOf sender) - _value) in
            let x1 = (M.upd x1 x2 x3) in
            x1)) /\ (cs1.bnb_cel_totalSupply == (cs0.bnb_cel_totalSupply - _value))) /\ (l1 == ((mk_event null bnb_cel_Burn (sender, _value))::l0)))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.bnb_cel_allowance == cs1.bnb_cel_allowance)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
      /\ (cs0.bnb_cel_freezeOf == cs1.bnb_cel_freezeOf)
  ))
=
let success:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let success = (if ((M.sel cs.bnb_cel_balanceOf sender) < _value) then begin
revert "sender doesn't have enough!";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let success = (if x1 then begin
revert "value leq 0";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if _value <= (M.sel cs.bnb_cel_balanceOf sender) then ((M.sel cs.bnb_cel_balanceOf sender) - _value) else revert "Underflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let x1 = ((if _value <= cs.bnb_cel_totalSupply then (cs.bnb_cel_totalSupply - _value) else revert "Underflow error")) in
let _ = bnb_cel_set_totalSupply self x1 in
let cs = get_contract self in
let _ = emit bnb_cel_Burn (sender, _value) in
let cs = get_contract self in
let balance = get_balance self in
true

let freeze (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_value:uint)
: Eth1 bool
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((M.sel cs.bnb_cel_freezeOf sender) > (uint_max - _value)) \/ ((M.sel cs.bnb_cel_balanceOf sender) < _value)) \/ (_value <= 0))
  )
  (fun bst0 success bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (((M.equal cs1.bnb_cel_balanceOf (
              let x1 = (cs0.bnb_cel_balanceOf) in
              let x2 = (sender) in
              let x3 = ((M.sel cs0.bnb_cel_balanceOf sender) - _value) in
              let x1 = (M.upd x1 x2 x3) in
              x1)) /\ (M.equal cs1.bnb_cel_freezeOf (
              let x1 = (cs0.bnb_cel_freezeOf) in
              let x2 = (sender) in
              let x3 = ((M.sel cs0.bnb_cel_freezeOf sender) + _value) in
              let x1 = (M.upd x1 x2 x3) in
              x1))) /\ (l1 == ((mk_event null bnb_cel_Freeze (sender, _value))::l0)))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.bnb_cel_allowance == cs1.bnb_cel_allowance)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_totalSupply == cs1.bnb_cel_totalSupply)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
  ))
=
let success:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let success = (if ((M.sel cs.bnb_cel_balanceOf sender) < _value) then begin
revert "sender doesn't have enough!";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let success = (if x1 then begin
revert "value leq 0";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if _value <= (M.sel cs.bnb_cel_balanceOf sender) then ((M.sel cs.bnb_cel_balanceOf sender) - _value) else revert "Underflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let x1 = ((if (M.sel cs.bnb_cel_freezeOf sender) <= uint_max - _value then ((M.sel cs.bnb_cel_freezeOf sender) + _value) else revert "Overflow error")) in
let freezeOf = cs.bnb_cel_freezeOf in
let _ = bnb_cel_set_freezeOf self (M.upd freezeOf sender x1) in
let cs = get_contract self in
let _ = emit bnb_cel_Freeze (sender, _value) in
let cs = get_contract self in
let balance = get_balance self in
true

let unfreeze (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_value:uint)
: Eth1 bool
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((M.sel cs.bnb_cel_balanceOf sender) > (uint_max - _value)) \/ ((M.sel cs.bnb_cel_freezeOf sender) < _value)) \/ (_value <= 0))
  )
  (fun bst0 success bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (((M.equal cs1.bnb_cel_balanceOf (
                let x1 = (cs0.bnb_cel_balanceOf) in
                let x2 = (sender) in
                let x3 = ((M.sel cs0.bnb_cel_balanceOf sender) + _value) in
                let x1 = (M.upd x1 x2 x3) in
                x1)) /\ (M.equal cs1.bnb_cel_freezeOf (
                let x1 = (cs0.bnb_cel_freezeOf) in
                let x2 = (sender) in
                let x3 = ((M.sel cs0.bnb_cel_freezeOf sender) - _value) in
                let x1 = (M.upd x1 x2 x3) in
                x1))) /\ (l1 == ((mk_event null bnb_cel_Unfreeze (sender, _value))::l0)))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.bnb_cel_allowance == cs1.bnb_cel_allowance)
      /\ (cs0.bnb_cel_symbol == cs1.bnb_cel_symbol)
      /\ (cs0.bnb_cel_name == cs1.bnb_cel_name)
      /\ (cs0.bnb_cel_owner == cs1.bnb_cel_owner)
      /\ (cs0.bnb_cel_totalSupply == cs1.bnb_cel_totalSupply)
      /\ (cs0.bnb_cel_decimals == cs1.bnb_cel_decimals)
  ))
=
let success:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let success = (if ((M.sel cs.bnb_cel_freezeOf sender) < _value) then begin
revert "sender doesn't have enough!";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_value <= 0) in
let success = (if x1 then begin
revert "value leq 0";
success end
else success) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if _value <= (M.sel cs.bnb_cel_freezeOf sender) then ((M.sel cs.bnb_cel_freezeOf sender) - _value) else revert "Underflow error")) in
let freezeOf = cs.bnb_cel_freezeOf in
let _ = bnb_cel_set_freezeOf self (M.upd freezeOf sender x1) in
let cs = get_contract self in
let x1 = ((if (M.sel cs.bnb_cel_balanceOf sender) <= uint_max - _value then ((M.sel cs.bnb_cel_balanceOf sender) + _value) else revert "Overflow error")) in
let balanceOf = cs.bnb_cel_balanceOf in
let _ = bnb_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let _ = emit bnb_cel_Unfreeze (sender, _value) in
let cs = get_contract self in
let balance = get_balance self in
true

let withdrawEther (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (amount:uint)
: Eth1 unit
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (sender =!= cs.bnb_cel_owner)
  )
  (fun bst0 x bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ ((l1 == ((mk_event cs0.bnb_cel_owner eTransfer amount)::l0)))
      /\ (b1 <= b0)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.bnb_cel_owner) then begin
revert "sender is not owner";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (amount > balance) then begin
revert "Insufficient balance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = transfer self (cs.bnb_cel_owner) amount in
let cs = get_contract self in
let balance = get_balance self in
()

let receive (self:bnb_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    bnb_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
  False)
  (fun bst0 x bst1 ->
    bnb_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
()