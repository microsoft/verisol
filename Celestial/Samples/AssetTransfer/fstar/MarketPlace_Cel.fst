(*Code generated by compiler*)

module MarketPlace_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val marketplace_cel_eMakeOffer : string
assume val marketplace_cel_eAcceptOffer : string
type marketplace_cel_state =
| MarketPlace_Active
| MarketPlace_OfferPlaced
| MarketPlace_NotionalAccept
| MarketPlace_BuyerAccept
| MarketPlace_SellerAccept
| MarketPlace_Accept

noeq type t_marketplace_cel = {
  marketplace_cel_seller : address;
  marketplace_cel_buyer : address;
  marketplace_cel_sellingPrice : uint;
  marketplace_cel_buyingPrice : uint;
  marketplace_cel_contractCurrentState : marketplace_cel_state;
}

(* Contract address type, liveness, and field range macros *)

type marketplace_cel_address = contract t_marketplace_cel
let marketplace_cel_live (c:marketplace_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract MarketPlace_Cel *)

let marketplace_cel_get_seller (c:marketplace_cel_address)
: StEth address
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).marketplace_cel_seller)
= let marketplace_cel_inst = get_contract c in
  marketplace_cel_inst.marketplace_cel_seller

let marketplace_cel_get_buyer (c:marketplace_cel_address)
: StEth address
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).marketplace_cel_buyer)
= let marketplace_cel_inst = get_contract c in
  marketplace_cel_inst.marketplace_cel_buyer

let marketplace_cel_get_sellingPrice (c:marketplace_cel_address)
: StEth uint
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).marketplace_cel_sellingPrice)
= let marketplace_cel_inst = get_contract c in
  marketplace_cel_inst.marketplace_cel_sellingPrice

let marketplace_cel_get_buyingPrice (c:marketplace_cel_address)
: StEth uint
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).marketplace_cel_buyingPrice)
= let marketplace_cel_inst = get_contract c in
  marketplace_cel_inst.marketplace_cel_buyingPrice

let marketplace_cel_get_contractCurrentState (c:marketplace_cel_address)
: StEth marketplace_cel_state
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).marketplace_cel_contractCurrentState)
= let marketplace_cel_inst = get_contract c in
  marketplace_cel_inst.marketplace_cel_contractCurrentState

(* Field setters for contract MarketPlace_Cel *)

let marketplace_cel_set_seller (c:marketplace_cel_address) (_seller:address)
: StEth unit
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    marketplace_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with marketplace_cel_seller = _seller }))
= let marketplace_cel_inst = get_contract c in
  let marketplace_cel_inst = { marketplace_cel_inst with marketplace_cel_seller = _seller } in
  set_contract c marketplace_cel_inst

let marketplace_cel_set_buyer (c:marketplace_cel_address) (_buyer:address)
: StEth unit
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    marketplace_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with marketplace_cel_buyer = _buyer }))
= let marketplace_cel_inst = get_contract c in
  let marketplace_cel_inst = { marketplace_cel_inst with marketplace_cel_buyer = _buyer } in
  set_contract c marketplace_cel_inst

let marketplace_cel_set_sellingPrice (c:marketplace_cel_address) (_sellingPrice:uint)
: StEth unit
  (fun st -> c `marketplace_cel_live` st.current
              /\ _sellingPrice >= 0 /\ _sellingPrice <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    marketplace_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with marketplace_cel_sellingPrice = _sellingPrice }))
= let marketplace_cel_inst = get_contract c in
  let marketplace_cel_inst = { marketplace_cel_inst with marketplace_cel_sellingPrice = _sellingPrice } in
  set_contract c marketplace_cel_inst

let marketplace_cel_set_buyingPrice (c:marketplace_cel_address) (_buyingPrice:uint)
: StEth unit
  (fun st -> c `marketplace_cel_live` st.current
              /\ _buyingPrice >= 0 /\ _buyingPrice <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    marketplace_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with marketplace_cel_buyingPrice = _buyingPrice }))
= let marketplace_cel_inst = get_contract c in
  let marketplace_cel_inst = { marketplace_cel_inst with marketplace_cel_buyingPrice = _buyingPrice } in
  set_contract c marketplace_cel_inst

let marketplace_cel_set_contractCurrentState (c:marketplace_cel_address) (_contractCurrentState:marketplace_cel_state)
: StEth unit
  (fun st -> c `marketplace_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    marketplace_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with marketplace_cel_contractCurrentState = _contractCurrentState }))
= let marketplace_cel_inst = get_contract c in
  let marketplace_cel_inst = { marketplace_cel_inst with marketplace_cel_contractCurrentState = _contractCurrentState } in
  set_contract c marketplace_cel_inst

let distinctBuyerSeller (self:marketplace_cel_address) (bst:bstate{self `marketplace_cel_live` bst}) : Type0 =
  let marketplace_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.marketplace_cel_seller =!= cs.marketplace_cel_buyer

let modifyOfferPost (_increase:bool) (_change:uint) (old_sellingPrice:uint) (new_sellingPrice:uint)
= if (_increase && ((old_sellingPrice + _change) <= uint_max)) then
  (new_sellingPrice == (old_sellingPrice + _change))
else
 (if (old_sellingPrice >= _change) then
  (new_sellingPrice == (old_sellingPrice - _change))
else
 (new_sellingPrice == old_sellingPrice)
)


let acceptPost (_from:address) (_seller:address) (_buyer:address) (old_state:marketplace_cel_state) (new_state:marketplace_cel_state)
= (((((((old_state == MarketPlace_NotionalAccept) /\ (_from == _buyer)) ==> (new_state == MarketPlace_BuyerAccept)))) /\ (((((old_state == MarketPlace_NotionalAccept) /\ (_from == _seller)) ==> (new_state == MarketPlace_SellerAccept))))) /\ (((((old_state == MarketPlace_BuyerAccept) /\ (_from == _seller)) ==> (new_state == MarketPlace_Accept))))) /\ (((((old_state == MarketPlace_SellerAccept) /\ (_from == _buyer)) ==> (new_state == MarketPlace_Accept))))

let marketplace_cel_constructor (self:marketplace_cel_address) (sender:address) (value:uint) (tx:tx) (block:block) (_seller:address) (_buyer:address)
: Eth1 unit
  (fun bst -> 
    marketplace_cel_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.marketplace_cel_seller == null)
      /\ (cs.marketplace_cel_buyer == null)
      /\ (cs.marketplace_cel_sellingPrice == 0)
      /\ (cs.marketplace_cel_buyingPrice == 0)
      /\ (cs.marketplace_cel_contractCurrentState == MarketPlace_Active)
      /\ (_seller =!= _buyer)
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      (distinctBuyerSeller self bst1)
      /\ (cs1.marketplace_cel_contractCurrentState == MarketPlace_Active)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = marketplace_cel_set_seller self _seller in
let cs = get_contract self in
let _ = marketplace_cel_set_buyer self _buyer in
let cs = get_contract self in
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_Active in
let cs = get_contract self in
()

let makeOffer (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_sellingPrice:uint)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.marketplace_cel_contractCurrentState =!= MarketPlace_Active)) \/ ((sender =!= cs.marketplace_cel_seller)))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ (((cs1.marketplace_cel_sellingPrice == _sellingPrice)) /\ ((cs1.marketplace_cel_contractCurrentState == MarketPlace_OfferPlaced)))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.marketplace_cel_buyer == cs1.marketplace_cel_buyer)
      /\ (cs0.marketplace_cel_seller == cs1.marketplace_cel_seller)
      /\ (cs0.marketplace_cel_buyingPrice == cs1.marketplace_cel_buyingPrice)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.marketplace_cel_seller) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (cs.marketplace_cel_contractCurrentState <> MarketPlace_Active) then begin
revert "<makeOffer> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = marketplace_cel_set_sellingPrice self _sellingPrice in
let cs = get_contract self in
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_OfferPlaced in
let cs = get_contract self in
let _ = emit marketplace_cel_eMakeOffer (cs.marketplace_cel_buyer, cs.marketplace_cel_sellingPrice) in
let cs = get_contract self in
let balance = get_balance self in
()

let modifyOffer (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_increase:bool) (_change:uint)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.marketplace_cel_contractCurrentState =!= MarketPlace_OfferPlaced)) \/ ((sender =!= cs.marketplace_cel_seller)))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ ((modifyOfferPost _increase _change cs0.marketplace_cel_sellingPrice cs1.marketplace_cel_sellingPrice))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.marketplace_cel_contractCurrentState == cs1.marketplace_cel_contractCurrentState)
      /\ (cs0.marketplace_cel_seller == cs1.marketplace_cel_seller)
      /\ (cs0.marketplace_cel_buyingPrice == cs1.marketplace_cel_buyingPrice)
      /\ (cs0.marketplace_cel_buyer == cs1.marketplace_cel_buyer)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.marketplace_cel_seller) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (op_Negation (((cs.marketplace_cel_contractCurrentState = MarketPlace_OfferPlaced) && (sender = cs.marketplace_cel_seller)))) in
let _ = (if x1 then begin
revert "<modifyOffer> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (_increase) then begin
let x1 = ((if cs.marketplace_cel_sellingPrice <= uint_max - _change then (cs.marketplace_cel_sellingPrice + _change) else revert "Overflow error")) in
let _ = marketplace_cel_set_sellingPrice self x1 in
let cs = get_contract self in
() end
else begin
let x1 = ((if _change <= cs.marketplace_cel_sellingPrice then (cs.marketplace_cel_sellingPrice - _change) else revert "Underflow error")) in
let _ = marketplace_cel_set_sellingPrice self x1 in
let cs = get_contract self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
()

let rejectOffer (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.marketplace_cel_contractCurrentState =!= MarketPlace_OfferPlaced)) \/ ((sender =!= cs.marketplace_cel_buyer)))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ (cs1.marketplace_cel_contractCurrentState == MarketPlace_Active)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.marketplace_cel_sellingPrice == cs1.marketplace_cel_sellingPrice)
      /\ (cs0.marketplace_cel_buyer == cs1.marketplace_cel_buyer)
      /\ (cs0.marketplace_cel_seller == cs1.marketplace_cel_seller)
      /\ (cs0.marketplace_cel_buyingPrice == cs1.marketplace_cel_buyingPrice)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.marketplace_cel_buyer) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (op_Negation (((cs.marketplace_cel_contractCurrentState = MarketPlace_OfferPlaced) && (sender = cs.marketplace_cel_buyer)))) in
let _ = (if x1 then begin
revert "<rejectOffer> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_Active in
let cs = get_contract self in
()

let acceptOfferPost (_seller:address) (old_state:marketplace_cel_state) (new_state:marketplace_cel_state) (_val:uint) (_sellingPrice:uint) (_buyingPrice:uint) (old_log:log) (new_log:log)
= ((_val >= _sellingPrice) ==> ((((_buyingPrice == _val)) /\ ((new_state == MarketPlace_NotionalAccept))) /\ (new_log == ((mk_event null marketplace_cel_eAcceptOffer (_seller, _buyingPrice))::old_log))))

let acceptOffer (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.marketplace_cel_contractCurrentState =!= MarketPlace_OfferPlaced)) \/ ((sender =!= cs.marketplace_cel_buyer)))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ ((acceptOfferPost cs0.marketplace_cel_seller cs0.marketplace_cel_contractCurrentState cs1.marketplace_cel_contractCurrentState value cs0.marketplace_cel_sellingPrice cs1.marketplace_cel_buyingPrice l0 l1))
      /\ (cs0.marketplace_cel_sellingPrice == cs1.marketplace_cel_sellingPrice)
      /\ (cs0.marketplace_cel_buyer == cs1.marketplace_cel_buyer)
      /\ (cs0.marketplace_cel_seller == cs1.marketplace_cel_seller)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((cs.marketplace_cel_contractCurrentState <> MarketPlace_OfferPlaced) || (sender <> cs.marketplace_cel_buyer)) then begin
revert "<acceptOffer> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (value >= cs.marketplace_cel_sellingPrice) in
let _ = (if x1 then begin
let _ = marketplace_cel_set_buyingPrice self value in
let cs = get_contract self in
let _ = emit marketplace_cel_eAcceptOffer (cs.marketplace_cel_seller, cs.marketplace_cel_buyingPrice) in
let cs = get_contract self in
let balance = get_balance self in
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_NotionalAccept in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
()

let acceptReverts (old_contractCurrentState:marketplace_cel_state)
= ((old_contractCurrentState =!= MarketPlace_NotionalAccept) /\ (old_contractCurrentState =!= MarketPlace_BuyerAccept)) /\ (old_contractCurrentState =!= MarketPlace_SellerAccept)

let accept (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((acceptReverts cs.marketplace_cel_contractCurrentState))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ ((acceptPost sender cs0.marketplace_cel_seller cs0.marketplace_cel_buyer cs0.marketplace_cel_contractCurrentState cs1.marketplace_cel_contractCurrentState))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.marketplace_cel_sellingPrice == cs1.marketplace_cel_sellingPrice)
      /\ (cs0.marketplace_cel_buyer == cs1.marketplace_cel_buyer)
      /\ (cs0.marketplace_cel_seller == cs1.marketplace_cel_seller)
      /\ (cs0.marketplace_cel_buyingPrice == cs1.marketplace_cel_buyingPrice)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (op_Negation ((((cs.marketplace_cel_contractCurrentState = MarketPlace_NotionalAccept) || (cs.marketplace_cel_contractCurrentState = MarketPlace_BuyerAccept)) || (cs.marketplace_cel_contractCurrentState = MarketPlace_SellerAccept)))) in
let _ = (if x1 then begin
revert "<accept> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((cs.marketplace_cel_contractCurrentState = MarketPlace_NotionalAccept) && (sender = cs.marketplace_cel_buyer)) in
let _ = (if x1 then begin
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_BuyerAccept in
let cs = get_contract self in
() end
else begin
let x1 = ((cs.marketplace_cel_contractCurrentState = MarketPlace_NotionalAccept) && (sender = cs.marketplace_cel_seller)) in
let _ = (if x1 then begin
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_SellerAccept in
let cs = get_contract self in
() end
else begin
let x1 = ((cs.marketplace_cel_contractCurrentState = MarketPlace_BuyerAccept) && (sender = cs.marketplace_cel_seller)) in
let _ = (if x1 then begin
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_Accept in
let cs = get_contract self in
() end
else begin
let x1 = ((cs.marketplace_cel_contractCurrentState = MarketPlace_SellerAccept) && (sender = cs.marketplace_cel_buyer)) in
let _ = (if x1 then begin
let _ = marketplace_cel_set_contractCurrentState self MarketPlace_Accept in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
()

let withdrawReverts (old_contractCurrentState:marketplace_cel_state) (_sender:address) (old_seller:address) (old_balance:uint) (old_buyingPrice:uint)
= ((old_contractCurrentState =!= MarketPlace_Accept) \/ (old_seller =!= _sender)) \/ (old_balance < old_buyingPrice)

let withdrawPost (old_balance:uint) (new_balance:uint) (old_buyingPrice:uint) (old_seller:address) (old_log:log) (new_log:log)
= (new_log == ((mk_event old_seller eTransfer old_buyingPrice)::old_log)) /\ (((new_balance == (old_balance - old_buyingPrice)) \/ (new_balance == old_balance)))

let withdraw (self:marketplace_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    marketplace_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (distinctBuyerSeller self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((withdrawReverts cs.marketplace_cel_contractCurrentState sender cs.marketplace_cel_seller b cs.marketplace_cel_buyingPrice))
  )
  (fun bst0 x bst1 ->
    marketplace_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (distinctBuyerSeller self bst1)
      /\ ((withdrawPost b0 b1 cs0.marketplace_cel_buyingPrice cs0.marketplace_cel_seller l0 l1))
      /\ (b1 <= b0)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (sender <> cs.marketplace_cel_seller) then begin
revert "";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (op_Negation (((cs.marketplace_cel_contractCurrentState = MarketPlace_Accept) && (sender = cs.marketplace_cel_seller)))) in
let _ = (if x1 then begin
revert "<withdraw> function invoked in invalid state";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (balance < cs.marketplace_cel_buyingPrice) then begin
revert "Insufficient balance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x2 = (cs.marketplace_cel_buyingPrice) in
let _ = transfer self (cs.marketplace_cel_seller) x2 in
let cs = get_contract self in
let balance = get_balance self in
()