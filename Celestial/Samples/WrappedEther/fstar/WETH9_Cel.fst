(*Code generated by compiler*)

module WETH9_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val weth9_cel_Approval : string
assume val weth9_cel_Transfer : string
assume val weth9_cel_Deposit : string
assume val weth9_cel_Withdrawal : string

noeq type t_weth9_cel = {
  weth9_cel_name : string;
  weth9_cel_symbol : string;
  weth9_cel_decimals : uint;
  weth9_cel_balanceOf : (m:(M.t address uint lt){M.def_of m == 0});
  weth9_cel_allowance : (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)});
  weth9_cel_totalBalance : uint;
}

(* Contract address type, liveness, and field range macros *)

type weth9_cel_address = contract t_weth9_cel
let weth9_cel_live (c:weth9_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract WETH9_Cel *)

let weth9_cel_get_name (c:weth9_cel_address)
: StEth string
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_name)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_name

let weth9_cel_get_symbol (c:weth9_cel_address)
: StEth string
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_symbol)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_symbol

let weth9_cel_get_decimals (c:weth9_cel_address)
: StEth uint
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_decimals)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_decimals

let weth9_cel_get_balanceOf (c:weth9_cel_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_balanceOf)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_balanceOf

let weth9_cel_get_allowance (c:weth9_cel_address)
: StEth (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_allowance)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_allowance

let weth9_cel_get_totalBalance (c:weth9_cel_address)
: StEth uint
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).weth9_cel_totalBalance)
= let weth9_cel_inst = get_contract c in
  weth9_cel_inst.weth9_cel_totalBalance

(* Field setters for contract WETH9_Cel *)

let weth9_cel_set_name (c:weth9_cel_address) (_name:string)
: StEth unit
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_name = _name }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_name = _name } in
  set_contract c weth9_cel_inst

let weth9_cel_set_symbol (c:weth9_cel_address) (_symbol:string)
: StEth unit
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_symbol = _symbol }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_symbol = _symbol } in
  set_contract c weth9_cel_inst

let weth9_cel_set_decimals (c:weth9_cel_address) (_decimals:uint)
: StEth unit
  (fun st -> c `weth9_cel_live` st.current
              /\ _decimals >= 0 /\ _decimals <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_decimals = _decimals }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_decimals = _decimals } in
  set_contract c weth9_cel_inst

let weth9_cel_set_balanceOf (c:weth9_cel_address) (_balanceOf:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_balanceOf = _balanceOf }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_balanceOf = _balanceOf } in
  set_contract c weth9_cel_inst

let weth9_cel_set_allowance (c:weth9_cel_address) (_allowance:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)}))
: StEth unit
  (fun st -> c `weth9_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_allowance = _allowance }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_allowance = _allowance } in
  set_contract c weth9_cel_inst

let weth9_cel_set_totalBalance (c:weth9_cel_address) (_totalBalance:uint)
: StEth unit
  (fun st -> c `weth9_cel_live` st.current
              /\ _totalBalance >= 0 /\ _totalBalance <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    weth9_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with weth9_cel_totalBalance = _totalBalance }))
= let weth9_cel_inst = get_contract c in
  let weth9_cel_inst = { weth9_cel_inst with weth9_cel_totalBalance = _totalBalance } in
  set_contract c weth9_cel_inst

let sumBalances (self:weth9_cel_address) (bst:bstate{self `weth9_cel_live` bst}) : Type0 =
  let weth9_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.weth9_cel_totalBalance == ((sum_mapping cs.weth9_cel_balanceOf))

let actualBalance (self:weth9_cel_address) (bst:bstate{self `weth9_cel_live` bst}) : Type0 =
  let weth9_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    weth9_cel_balance == cs.weth9_cel_totalBalance

let deposit (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((value + cs.weth9_cel_totalBalance) > uint_max))
  )
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
      /\ ((M.equal cs1.weth9_cel_balanceOf (
      let x1 = (cs0.weth9_cel_balanceOf) in
      let x2 = (sender) in
      let x3 = ((M.sel cs0.weth9_cel_balanceOf sender) + value) in
      let x1 = (M.upd x1 x2 x3) in
      x1)) /\ (l1 == ((mk_event null weth9_cel_Deposit (sender, value))::l0)))
      /\ (cs0.weth9_cel_decimals == cs1.weth9_cel_decimals)
      /\ (cs0.weth9_cel_allowance == cs1.weth9_cel_allowance)
      /\ (cs0.weth9_cel_name == cs1.weth9_cel_name)
      /\ (cs0.weth9_cel_symbol == cs1.weth9_cel_symbol)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if cs.weth9_cel_totalBalance <= uint_max - value then (cs.weth9_cel_totalBalance + value) else revert "Overflow error")) in
let _ = weth9_cel_set_totalBalance self x1 in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.weth9_cel_balanceOf sender) value)) in
let balanceOf = cs.weth9_cel_balanceOf in
let _ = weth9_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let _ = emit weth9_cel_Deposit (sender, value) in
let cs = get_contract self in
let balance = get_balance self in
()

let withdraw (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_wad:uint)
: Eth1 unit
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((b < _wad) \/ ((M.sel cs.weth9_cel_balanceOf sender) < _wad))
  )
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
      /\ ((l1 == ((mk_event null weth9_cel_Withdrawal (sender, _wad))::(mk_event sender eTransfer _wad)::l0)) /\ (if (b1 < b0) then
  (M.equal cs1.weth9_cel_balanceOf (
            let x1 = (cs0.weth9_cel_balanceOf) in
            let x2 = (sender) in
            let x3 = ((M.sel cs0.weth9_cel_balanceOf sender) - _wad) in
            let x1 = (M.upd x1 x2 x3) in
            x1))
else
 (M.equal cs1.weth9_cel_balanceOf cs0.weth9_cel_balanceOf)
))
      /\ (b1 <= b0)
      /\ (cs0.weth9_cel_decimals == cs1.weth9_cel_decimals)
      /\ (cs0.weth9_cel_allowance == cs1.weth9_cel_allowance)
      /\ (cs0.weth9_cel_name == cs1.weth9_cel_name)
      /\ (cs0.weth9_cel_symbol == cs1.weth9_cel_symbol)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((M.sel cs.weth9_cel_balanceOf sender) < _wad) then begin
revert "Insufficient balance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = transfer self sender _wad in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit weth9_cel_Withdrawal (sender, _wad) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (balance < cs.weth9_cel_totalBalance) then begin
let x1 = ((_sub (M.sel cs.weth9_cel_balanceOf sender) _wad)) in
let balanceOf = cs.weth9_cel_balanceOf in
let _ = weth9_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let _ = weth9_cel_set_totalBalance self (_sub cs.weth9_cel_totalBalance _wad) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
()

let totalSupply (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 uint
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst -> False)
  (fun bst0 a bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
      /\ ((a == b0))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let a:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (balance) in
let a = x1 in
let cs = get_contract self in
a

let approve (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_guy:address) (_wad:uint)
: Eth1 bool
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
      /\ (M.equal cs1.weth9_cel_allowance (
        let x1 = (cs0.weth9_cel_allowance) in
        let x2 = (sender) in
        let x3 = (
          let x1 = (M.sel cs0.weth9_cel_allowance sender) in
          let x2 = (_guy) in
          let x3 = (_wad) in
          let x1 = (M.upd x1 x2 x3) in
          x1) in
        let x1 = (M.upd x1 x2 x3) in
        x1))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.weth9_cel_decimals == cs1.weth9_cel_decimals)
      /\ (cs0.weth9_cel_symbol == cs1.weth9_cel_symbol)
      /\ (cs0.weth9_cel_balanceOf == cs1.weth9_cel_balanceOf)
      /\ (cs0.weth9_cel_totalBalance == cs1.weth9_cel_totalBalance)
      /\ (cs0.weth9_cel_name == cs1.weth9_cel_name)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x5 = (_wad) in
let x4 = cs.weth9_cel_allowance in

let x3 = (sender) in
let x2 = (M.sel x4 x3) in
let x1 = (_guy) in
let x0 = (M.sel x2 x1) in
    
let _ = weth9_cel_set_allowance self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit weth9_cel_Approval (sender, _guy, _wad) in
let cs = get_contract self in
let balance = get_balance self in
true

let transferFromReverts (old_balanceOf:(m:(M.t address uint lt){M.def_of m == 0})) (old_allowance:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (_sender:address) (_src:address) (_dst:address) (_wad:uint)
= ((_src == _dst) \/ ((M.sel old_balanceOf _src) < _wad)) \/ (((_src =!= _sender) /\ ((M.sel (M.sel old_allowance _src) _sender) =!= uint_max)) /\ ((M.sel (M.sel old_allowance _src) _sender) < _wad))

let transferFromPost (old_balanceOf:(m:(M.t address uint lt){M.def_of m == 0})) (new_balanceOf:(m:(M.t address uint lt){M.def_of m == 0})) (old_allowance:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (new_allowance:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (_sender:address) (_src:address) (_dst:address) (_wad:uint)
= (((if ((_src <> _sender) && ((M.sel (M.sel old_allowance _src) _sender) <> uint_max)) then
  (((M.sel (M.sel old_allowance _src) _sender) >= _wad) /\ (M.equal new_allowance (
                  let x1 = (old_allowance) in
                  let x2 = (_src) in
                  let x3 = (
                    let x1 = (M.sel old_allowance _src) in
                    let x2 = (_sender) in
                    let x3 = (((M.sel (M.sel old_allowance _src) _sender) - _wad)) in
                    let x1 = (M.upd x1 x2 x3) in
                    x1) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1)))
else
 (M.equal new_allowance old_allowance)
) /\ (((M.sel old_balanceOf _dst) + _wad) <= uint_max)) /\ ((M.sel old_balanceOf _src) >= _wad)) /\ (M.equal new_balanceOf (
          let x1 = (old_balanceOf) in
          let x2 = (_src) in
          let x3 = ((M.sel old_balanceOf _src) - _wad) in
          let x1 = (M.upd x1 x2 x3) in
          let x2 = (_dst) in
          let x3 = ((M.sel old_balanceOf _dst) + _wad) in
          let x1 = (M.upd x1 x2 x3) in
          x1))

let transferFrom (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_src:address) (_dst:address) (_wad:uint)
: Eth1 bool
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((transferFromReverts cs.weth9_cel_balanceOf cs.weth9_cel_allowance sender _src _dst _wad))
  )
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
      /\ ((transferFromPost cs0.weth9_cel_balanceOf cs1.weth9_cel_balanceOf cs0.weth9_cel_allowance cs1.weth9_cel_allowance sender _src _dst _wad))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.weth9_cel_decimals == cs1.weth9_cel_decimals)
      /\ (cs0.weth9_cel_totalBalance == cs1.weth9_cel_totalBalance)
      /\ (cs0.weth9_cel_name == cs1.weth9_cel_name)
      /\ (cs0.weth9_cel_symbol == cs1.weth9_cel_symbol)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_src = _dst) in
let _ = (if x1 then begin
revert "Redundant transfer";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((M.sel cs.weth9_cel_balanceOf _src) < _wad) then begin
revert "Insufficient balance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((_src <> sender) && ((M.sel (M.sel cs.weth9_cel_allowance _src) sender) <> uint_max)) then begin
let _ = (if ((M.sel (M.sel cs.weth9_cel_allowance _src) sender) < _wad) then begin
revert "Insufficient allowance";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x5 = ((_sub (M.sel (M.sel cs.weth9_cel_allowance _src) sender) _wad)) in
let x4 = cs.weth9_cel_allowance in

let x3 = (_src) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
    
let _ = weth9_cel_set_allowance self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((_sub (M.sel cs.weth9_cel_balanceOf _src) _wad)) in
let balanceOf = cs.weth9_cel_balanceOf in
let _ = weth9_cel_set_balanceOf self (M.upd balanceOf _src x1) in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.weth9_cel_balanceOf _dst) _wad)) in
let balanceOf = cs.weth9_cel_balanceOf in
let _ = weth9_cel_set_balanceOf self (M.upd balanceOf _dst x1) in
let cs = get_contract self in
let _ = emit weth9_cel_Transfer (_src, _dst, _wad) in
let cs = get_contract self in
let balance = get_balance self in
true

let _transfer (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_dst:address) (_wad:uint)
: Eth1 bool
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((transferFromReverts cs.weth9_cel_balanceOf cs.weth9_cel_allowance self sender _dst _wad))
  )
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1
     /\ (sumBalances self bst1)
     /\ (actualBalance self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
(transferFrom self self 0 tx block sender _dst _wad)

let receive (self:weth9_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    weth9_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sumBalances self bst)
      /\ (actualBalance self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
  False)
  (fun bst0 x bst1 ->
    weth9_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (sumBalances self bst1)
      /\ (actualBalance self bst1)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if cs.weth9_cel_totalBalance <= uint_max - value then (cs.weth9_cel_totalBalance + value) else revert "Overflow error")) in
let _ = weth9_cel_set_totalBalance self x1 in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.weth9_cel_balanceOf sender) value)) in
let balanceOf = cs.weth9_cel_balanceOf in
let _ = weth9_cel_set_balanceOf self (M.upd balanceOf sender x1) in
let cs = get_contract self in
let _ = emit weth9_cel_Deposit (sender, value) in
let cs = get_contract self in
let balance = get_balance self in
()