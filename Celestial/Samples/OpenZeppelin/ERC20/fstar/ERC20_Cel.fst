(*Code generated by compiler*)

module ERC20_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array


noeq type t_erc20_cel = {
  erc20_cel_balances : (m:(M.t address uint lt){M.def_of m == 0});
  erc20_cel_allowances : (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)});
  erc20_cel_totalSupply : uint;
}

(* Contract address type, liveness, and field range macros *)

type erc20_cel_address = contract t_erc20_cel
let erc20_cel_live (c:erc20_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract ERC20_Cel *)

let erc20_cel_get_balances (c:erc20_cel_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `erc20_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).erc20_cel_balances)
= let erc20_cel_inst = get_contract c in
  erc20_cel_inst.erc20_cel_balances

let erc20_cel_get_allowances (c:erc20_cel_address)
: StEth (m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})
  (fun st -> c `erc20_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).erc20_cel_allowances)
= let erc20_cel_inst = get_contract c in
  erc20_cel_inst.erc20_cel_allowances

let erc20_cel_get_totalSupply (c:erc20_cel_address)
: StEth uint
  (fun st -> c `erc20_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).erc20_cel_totalSupply)
= let erc20_cel_inst = get_contract c in
  erc20_cel_inst.erc20_cel_totalSupply

(* Field setters for contract ERC20_Cel *)

let erc20_cel_set_balances (c:erc20_cel_address) (_balances:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `erc20_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    erc20_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with erc20_cel_balances = _balances }))
= let erc20_cel_inst = get_contract c in
  let erc20_cel_inst = { erc20_cel_inst with erc20_cel_balances = _balances } in
  set_contract c erc20_cel_inst

let erc20_cel_set_allowances (c:erc20_cel_address) (_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)}))
: StEth unit
  (fun st -> c `erc20_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    erc20_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with erc20_cel_allowances = _allowances }))
= let erc20_cel_inst = get_contract c in
  let erc20_cel_inst = { erc20_cel_inst with erc20_cel_allowances = _allowances } in
  set_contract c erc20_cel_inst

let erc20_cel_set_totalSupply (c:erc20_cel_address) (_totalSupply:uint)
: StEth unit
  (fun st -> c `erc20_cel_live` st.current
              /\ _totalSupply >= 0 /\ _totalSupply <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    erc20_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with erc20_cel_totalSupply = _totalSupply }))
= let erc20_cel_inst = get_contract c in
  let erc20_cel_inst = { erc20_cel_inst with erc20_cel_totalSupply = _totalSupply } in
  set_contract c erc20_cel_inst

let totalSupplyInv (self:erc20_cel_address) (bst:bstate{self `erc20_cel_live` bst}) : Type0 =
  let erc20_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.erc20_cel_totalSupply == ((sum_mapping cs.erc20_cel_balances))

let nullCheckPre (a1:address) (a2:address)
= (a1 =!= null) /\ (a2 =!= null)

let _msgSender (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 address
  (fun bst ->
    erc20_cel_live self bst
  )
  (fun bst -> False)
  (fun bst0 ret bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      (ret == sender)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let ret:address = null in
let cs = get_contract self in
let balance = get_balance self in
sender

let transferPost (old_balances:(m:(M.t address uint lt){M.def_of m == 0})) (new_balances:(m:(M.t address uint lt){M.def_of m == 0})) (_from:address) (_to:address) (_amount:uint)
= ((((M.sel old_balances _from) >= _amount)) /\ ((((M.sel old_balances _to) + _amount) <= uint_max))) /\ (if (_from = _to) then
  (M.equal new_balances old_balances)
else
 (M.equal new_balances (
        let x1 = (old_balances) in
        let x2 = (_from) in
        let x3 = ((M.sel old_balances _from) - _amount) in
        let x1 = (M.upd x1 x2 x3) in
        let x2 = (_to) in
        let x3 = ((M.sel old_balances _to) + _amount) in
        let x1 = (M.upd x1 x2 x3) in
        x1))
)

let _approvePost (old_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (new_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (_owner:address) (_spender:address) (_amount:uint)
= M.equal new_allowances (
    let x1 = (old_allowances) in
    let x2 = (_owner) in
    let x3 = (
      let x1 = (M.sel old_allowances _owner) in
      let x2 = (_spender) in
      let x3 = (_amount) in
      let x1 = (M.upd x1 x2 x3) in
      x1) in
    let x1 = (M.upd x1 x2 x3) in
    x1)

let transferFromPost (old_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (new_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (old_balances:(m:(M.t address uint lt){M.def_of m == 0})) (new_balances:(m:(M.t address uint lt){M.def_of m == 0})) (_from:address) (_to:address) (_sender:address) (_amount:uint)
= (((transferPost old_balances new_balances _from _to _amount)) /\ ((M.sel (M.sel old_allowances _from) _sender) >= _amount)) /\ ((_approvePost old_allowances new_allowances _from _sender ((M.sel (M.sel old_allowances _from) _sender) - _amount)))

let getTotalSupply (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 uint
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
cs.erc20_cel_totalSupply

let balanceOf (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (account:address)
: Eth1 uint
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
M.sel cs.erc20_cel_balances account

let _transfer (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_from:address) (_to:address) (_amount:uint)
: Eth1 unit
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      ((((nullCheckPre _from _to)) /\ ((M.sel cs.erc20_cel_balances _from) >= _amount)) /\ (((M.sel cs.erc20_cel_balances _to) + _amount) <= uint_max))
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((transferPost cs0.erc20_cel_balances cs1.erc20_cel_balances _from _to _amount))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
      /\ (cs0.erc20_cel_allowances == cs1.erc20_cel_allowances)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (_from <> _to) then begin
let x1 = ((_sub (M.sel cs.erc20_cel_balances _from) (_amount))) in
let balances = cs.erc20_cel_balances in
let _ = erc20_cel_set_balances self (M.upd balances _from x1) in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.erc20_cel_balances _to) (_amount))) in
let balances = cs.erc20_cel_balances in
let _ = erc20_cel_set_balances self (M.upd balances _to x1) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
()

let mintReverts (_account:address) (old_totalSupply:uint) (old_balances:(m:(M.t address uint lt){M.def_of m == 0})) (_amount:uint)
= (_account == null) \/ (((old_totalSupply > (uint_max - _amount)) \/ ((M.sel old_balances _account) > (uint_max - _amount))))

let burnReverts (_account:address) (old_totalSupply:uint) (old_balances:(m:(M.t address uint lt){M.def_of m == 0})) (_amount:uint)
= (_account == null) \/ ((((M.sel old_balances _account) < _amount) \/ (old_totalSupply < _amount)))

let mint (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_account:address) (_amount:uint)
: Eth1 unit
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((mintReverts _account cs.erc20_cel_totalSupply cs.erc20_cel_balances _amount))
  )
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ ((cs1.erc20_cel_totalSupply == (cs0.erc20_cel_totalSupply + _amount)) /\ (M.equal cs1.erc20_cel_balances (
      let x1 = (cs0.erc20_cel_balances) in
      let x2 = (_account) in
      let x3 = ((M.sel cs0.erc20_cel_balances _account) + _amount) in
      let x1 = (M.upd x1 x2 x3) in
      x1)))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_allowances == cs1.erc20_cel_allowances)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_account = null) in
let _ = (if x1 then begin
revert "ERC20: mint to the zero address";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((cs.erc20_cel_totalSupply <= ((_sub uint_max _amount))) && ((M.sel cs.erc20_cel_balances _account) <= ((_sub uint_max _amount)))) in
let _ = (if x1 then begin
let _ = erc20_cel_set_totalSupply self (_add cs.erc20_cel_totalSupply _amount) in
let cs = get_contract self in
let x1 = ((_add (M.sel cs.erc20_cel_balances _account) _amount)) in
let balances = cs.erc20_cel_balances in
let _ = erc20_cel_set_balances self (M.upd balances _account x1) in
let cs = get_contract self in
() end
else begin
revert "Overflow";
() end) in
let cs = get_contract self in
let balance = get_contract self in
()

let burn (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_account:address) (_amount:uint)
: Eth1 unit
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((burnReverts _account cs.erc20_cel_totalSupply cs.erc20_cel_balances _amount))
  )
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ ((cs1.erc20_cel_totalSupply == (cs0.erc20_cel_totalSupply - _amount)) /\ (M.equal cs1.erc20_cel_balances (
      let x1 = (cs0.erc20_cel_balances) in
      let x2 = (_account) in
      let x3 = ((M.sel cs0.erc20_cel_balances _account) - _amount) in
      let x1 = (M.upd x1 x2 x3) in
      x1)))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_allowances == cs1.erc20_cel_allowances)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_account = null) in
let _ = (if x1 then begin
revert "ERC20: burn from the zero address";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (((M.sel cs.erc20_cel_balances _account) >= _amount) && (cs.erc20_cel_totalSupply >= _amount)) in
let _ = (if x1 then begin
let _ = erc20_cel_set_totalSupply self (_sub cs.erc20_cel_totalSupply _amount) in
let cs = get_contract self in
let x1 = ((_sub (M.sel cs.erc20_cel_balances _account) _amount)) in
let balances = cs.erc20_cel_balances in
let _ = erc20_cel_set_balances self (M.upd balances _account x1) in
let cs = get_contract self in
() end
else begin
revert "Underflow";
() end) in
let cs = get_contract self in
let balance = get_contract self in
()

let _approve (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_owner:address) (_spender:address) (_amount:uint)
: Eth1 unit
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      ((((nullCheckPre _owner _spender)) /\ (_amount >= 0)) /\ (_amount <= uint_max))
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((_approvePost cs0.erc20_cel_allowances cs1.erc20_cel_allowances _owner _spender _amount))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_balances == cs1.erc20_cel_balances)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x5 = (_amount) in
let x4 = cs.erc20_cel_allowances in

let x3 = (_owner) in
let x2 = (M.sel x4 x3) in
let x1 = (_spender) in
let x0 = (M.sel x2 x1) in

let _ = erc20_cel_set_allowances self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
()

let burnFrom (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_account:address) (_amount:uint)
: Eth1 unit
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((burnReverts _account cs.erc20_cel_totalSupply cs.erc20_cel_balances _amount))
  )
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (burn self self 0 tx block _account _amount) in
let cs = get_contract self in
let x1 = (((_account <> null) && (sender <> null)) && ((M.sel (M.sel cs.erc20_cel_allowances _account) sender) >= _amount)) in
let _ = (if x1 then begin
let _ = (_approve self self 0 tx block _account sender (_sub (M.sel (M.sel cs.erc20_cel_allowances _account) sender) _amount)) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
()

let transfer_ (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_to:address) (_amount:uint)
: Eth1 bool
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (_to == null)
  )
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (((M.sel cs1.erc20_cel_balances sender) <= (M.sel cs0.erc20_cel_balances sender)) /\ ((M.sel cs0.erc20_cel_balances _to) >= (M.sel cs0.erc20_cel_balances _to)))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
      /\ (cs0.erc20_cel_allowances == cs1.erc20_cel_allowances)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (_to = null) in
let _ = (if x1 then begin
revert "Sender/Recipient must be non-null";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (((M.sel cs.erc20_cel_balances sender) >= _amount) && ((M.sel cs.erc20_cel_balances _to) <= ((_sub uint_max _amount)))) in
let _ = (if x1 then begin
let _ = (_transfer self self 0 tx block sender _to _amount) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
true

let allowance (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_owner:address) (_spender:address)
: Eth1 uint
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
M.sel (M.sel cs.erc20_cel_allowances _owner) _spender

let approve (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_spender:address) (_amount:uint)
: Eth1 bool
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_balances == cs1.erc20_cel_balances)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (_spender <> null) then begin
let _ = (_approve self self 0 tx block sender _spender _amount) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
true

let transferFromReverts (_to:address) (_from:address) (_amount:uint) (old_balances:(m:(M.t address uint lt){M.def_of m == 0})) (old_allowances:(m:(M.t address (m:(M.t address uint lt){M.def_of m == 0}) lt){M.def_of m == M.const (0)})) (_sender:address)
= (((_from == null) \/ (_to == null)) \/ ((((M.sel old_balances _from) < _amount) \/ ((M.sel old_balances _to) > (uint_max - _amount))))) \/ (((M.sel (M.sel old_allowances _from) _sender) < _amount))

let transferFrom (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_from:address) (_to:address) (_amount:uint)
: Eth1 bool
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((transferFromReverts _to _from _amount cs.erc20_cel_balances cs.erc20_cel_allowances sender))
  )
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ ((transferFromPost cs0.erc20_cel_allowances cs1.erc20_cel_allowances cs0.erc20_cel_balances cs1.erc20_cel_balances _from _to sender _amount))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((_from = null) || (_to = null)) in
let _ = (if x1 then begin
revert "<ErrorLog> from/to addresses are null";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (((M.sel cs.erc20_cel_balances _from) >= _amount) && ((M.sel cs.erc20_cel_balances _to) <= ((_sub uint_max _amount)))) in
let _ = (if x1 then begin
let _ = (_transfer self self 0 tx block _from _to _amount) in
let cs = get_contract self in
() end
else begin
revert "<ErrorLog> Underflow/Overflow";
() end) in
let cs = get_contract self in
let balance = get_contract self in
let x1 = ((M.sel (M.sel cs.erc20_cel_allowances _from) sender) >= _amount) in
let _ = (if x1 then begin
let _ = (_approve self self 0 tx block _from sender (_sub (M.sel (M.sel cs.erc20_cel_allowances _from) sender) _amount)) in
let cs = get_contract self in
() end
else begin
revert "<ErrorLog> Allowance insufficient";
() end) in
let cs = get_contract self in
let balance = get_contract self in
true

let increaseAllowance (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_spender:address) (_addedValue:uint)
: Eth1 bool
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_balances == cs1.erc20_cel_balances)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((_spender <> null) && ((M.sel (M.sel cs.erc20_cel_allowances sender) _spender) <= ((_sub uint_max _addedValue)))) in
let _ = (if x1 then begin
let _ = (_approve self self 0 tx block sender _spender (_add (M.sel (M.sel cs.erc20_cel_allowances sender) _spender) _addedValue)) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
true

let decreaseAllowance (self:erc20_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_spender:address) (_subtractedValue:uint)
: Eth1 bool
  (fun bst ->
    erc20_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (totalSupplyInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    erc20_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (totalSupplyInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.erc20_cel_balances == cs1.erc20_cel_balances)
      /\ (cs0.erc20_cel_totalSupply == cs1.erc20_cel_totalSupply)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((_spender <> null) && ((M.sel (M.sel cs.erc20_cel_allowances sender) _spender) >= _subtractedValue)) in
let _ = (if x1 then begin
let _ = (_approve self self 0 tx block sender _spender (_sub (M.sel (M.sel cs.erc20_cel_allowances sender) _spender) _subtractedValue)) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
true