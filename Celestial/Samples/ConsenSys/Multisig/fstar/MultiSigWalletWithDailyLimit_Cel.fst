(*Code generated by compiler*)

module MultiSigWalletWithDailyLimit_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val multisigwalletwithdailylimit_cel_Confirmation : string
assume val multisigwalletwithdailylimit_cel_Revocation : string
assume val multisigwalletwithdailylimit_cel_Submission : string
assume val multisigwalletwithdailylimit_cel_Execution : string
assume val multisigwalletwithdailylimit_cel_OwnerAddition : string
assume val multisigwalletwithdailylimit_cel_OwnerRemoval : string
assume val multisigwalletwithdailylimit_cel_RequirementChange : string
assume val multisigwalletwithdailylimit_cel_DailyLimitChange : string
noeq type multisigwalletwithdailylimit_cel_Transaction = {
  multisigwalletwithdailylimit_cel_destination : address;
  multisigwalletwithdailylimit_cel_tval : uint;
  multisigwalletwithdailylimit_cel_executed : bool
}


noeq type t_multisigwalletwithdailylimit_cel = {
  multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT : uint;
  multisigwalletwithdailylimit_cel_transactions : (m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }});
  multisigwalletwithdailylimit_cel_confirmationCounts : (m:(M.t uint uint lt){M.def_of m == 0});
  multisigwalletwithdailylimit_cel_confirmations : (m:(M.t uint (m:(M.t address bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)});
  multisigwalletwithdailylimit_cel_isOwner : (m:(M.t address bool lt){M.def_of m == false});
  multisigwalletwithdailylimit_cel_ownerCount : uint;
  multisigwalletwithdailylimit_cel_required : uint;
  multisigwalletwithdailylimit_cel_transactionCount : uint;
  multisigwalletwithdailylimit_cel_walletActive : bool;
  multisigwalletwithdailylimit_cel_tx_isConfirmed : bool;
  multisigwalletwithdailylimit_cel_tx_isUnderLimit : bool;
  multisigwalletwithdailylimit_cel_dailyLimit : uint;
  multisigwalletwithdailylimit_cel_lastDay : uint;
  multisigwalletwithdailylimit_cel_spentToday : uint;
}

(* Contract address type, liveness, and field range macros *)

type multisigwalletwithdailylimit_cel_address = contract t_multisigwalletwithdailylimit_cel
let multisigwalletwithdailylimit_cel_live (c:multisigwalletwithdailylimit_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract MultiSigWalletWithDailyLimit_Cel *)

let multisigwalletwithdailylimit_cel_get_MAX_OWNER_COUNT (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT

let multisigwalletwithdailylimit_cel_get_transactions (c:multisigwalletwithdailylimit_cel_address)
: StEth (m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }})
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_transactions)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_transactions

let multisigwalletwithdailylimit_cel_get_confirmationCounts (c:multisigwalletwithdailylimit_cel_address)
: StEth (m:(M.t uint uint lt){M.def_of m == 0})
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_confirmationCounts)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_confirmationCounts

let multisigwalletwithdailylimit_cel_get_confirmations (c:multisigwalletwithdailylimit_cel_address)
: StEth (m:(M.t uint (m:(M.t address bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)})
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_confirmations)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_confirmations

let multisigwalletwithdailylimit_cel_get_isOwner (c:multisigwalletwithdailylimit_cel_address)
: StEth (m:(M.t address bool lt){M.def_of m == false})
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_isOwner)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_isOwner

let multisigwalletwithdailylimit_cel_get_ownerCount (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_ownerCount)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_ownerCount

let multisigwalletwithdailylimit_cel_get_required (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_required)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_required

let multisigwalletwithdailylimit_cel_get_transactionCount (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_transactionCount)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_transactionCount

let multisigwalletwithdailylimit_cel_get_walletActive (c:multisigwalletwithdailylimit_cel_address)
: StEth bool
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_walletActive)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_walletActive

let multisigwalletwithdailylimit_cel_get_tx_isConfirmed (c:multisigwalletwithdailylimit_cel_address)
: StEth bool
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_tx_isConfirmed)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_tx_isConfirmed

let multisigwalletwithdailylimit_cel_get_tx_isUnderLimit (c:multisigwalletwithdailylimit_cel_address)
: StEth bool
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_tx_isUnderLimit)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_tx_isUnderLimit

let multisigwalletwithdailylimit_cel_get_dailyLimit (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_dailyLimit)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_dailyLimit

let multisigwalletwithdailylimit_cel_get_lastDay (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_lastDay)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_lastDay

let multisigwalletwithdailylimit_cel_get_spentToday (c:multisigwalletwithdailylimit_cel_address)
: StEth uint
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).multisigwalletwithdailylimit_cel_spentToday)
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  multisigwalletwithdailylimit_cel_inst.multisigwalletwithdailylimit_cel_spentToday

(* Field setters for contract MultiSigWalletWithDailyLimit_Cel *)

let multisigwalletwithdailylimit_cel_set_MAX_OWNER_COUNT (c:multisigwalletwithdailylimit_cel_address) (_MAX_OWNER_COUNT:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _MAX_OWNER_COUNT >= 0 /\ _MAX_OWNER_COUNT <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT = _MAX_OWNER_COUNT }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT = _MAX_OWNER_COUNT } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_transactions (c:multisigwalletwithdailylimit_cel_address) (_transactions:(m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }}))
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_transactions = _transactions }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_transactions = _transactions } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_confirmationCounts (c:multisigwalletwithdailylimit_cel_address) (_confirmationCounts:(m:(M.t uint uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_confirmationCounts = _confirmationCounts }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_confirmationCounts = _confirmationCounts } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_confirmations (c:multisigwalletwithdailylimit_cel_address) (_confirmations:(m:(M.t uint (m:(M.t address bool lt){M.def_of m == false}) lt){M.def_of m == M.const (false)}))
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_confirmations = _confirmations }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_confirmations = _confirmations } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_isOwner (c:multisigwalletwithdailylimit_cel_address) (_isOwner:(m:(M.t address bool lt){M.def_of m == false}))
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_isOwner = _isOwner }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_isOwner = _isOwner } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_ownerCount (c:multisigwalletwithdailylimit_cel_address) (_ownerCount:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _ownerCount >= 0 /\ _ownerCount <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_ownerCount = _ownerCount }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_ownerCount = _ownerCount } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_required (c:multisigwalletwithdailylimit_cel_address) (_required:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _required >= 0 /\ _required <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_required = _required }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_required = _required } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_transactionCount (c:multisigwalletwithdailylimit_cel_address) (_transactionCount:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _transactionCount >= 0 /\ _transactionCount <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_transactionCount = _transactionCount }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_transactionCount = _transactionCount } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_walletActive (c:multisigwalletwithdailylimit_cel_address) (_walletActive:bool)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_walletActive = _walletActive }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_walletActive = _walletActive } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_tx_isConfirmed (c:multisigwalletwithdailylimit_cel_address) (_tx_isConfirmed:bool)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_tx_isConfirmed = _tx_isConfirmed }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_tx_isConfirmed = _tx_isConfirmed } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_tx_isUnderLimit (c:multisigwalletwithdailylimit_cel_address) (_tx_isUnderLimit:bool)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_tx_isUnderLimit = _tx_isUnderLimit }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_tx_isUnderLimit = _tx_isUnderLimit } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_dailyLimit (c:multisigwalletwithdailylimit_cel_address) (_dailyLimit:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _dailyLimit >= 0 /\ _dailyLimit <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_dailyLimit = _dailyLimit }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_dailyLimit = _dailyLimit } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_lastDay (c:multisigwalletwithdailylimit_cel_address) (_lastDay:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _lastDay >= 0 /\ _lastDay <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_lastDay = _lastDay }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_lastDay = _lastDay } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let multisigwalletwithdailylimit_cel_set_spentToday (c:multisigwalletwithdailylimit_cel_address) (_spentToday:uint)
: StEth unit
  (fun st -> c `multisigwalletwithdailylimit_cel_live` st.current
              /\ _spentToday >= 0 /\ _spentToday <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    multisigwalletwithdailylimit_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with multisigwalletwithdailylimit_cel_spentToday = _spentToday }))
= let multisigwalletwithdailylimit_cel_inst = get_contract c in
  let multisigwalletwithdailylimit_cel_inst = { multisigwalletwithdailylimit_cel_inst with multisigwalletwithdailylimit_cel_spentToday = _spentToday } in
  set_contract c multisigwalletwithdailylimit_cel_inst

let walletActiveInv (self:multisigwalletwithdailylimit_cel_address) (bst:bstate{self `multisigwalletwithdailylimit_cel_live` bst}) : Type0 =
  let multisigwalletwithdailylimit_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    (cs.multisigwalletwithdailylimit_cel_walletActive ==> (cs.multisigwalletwithdailylimit_cel_required <= cs.multisigwalletwithdailylimit_cel_ownerCount))

let ownerCountInv (self:multisigwalletwithdailylimit_cel_address) (bst:bstate{self `multisigwalletwithdailylimit_cel_live` bst}) : Type0 =
  let multisigwalletwithdailylimit_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.multisigwalletwithdailylimit_cel_ownerCount <= cs.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT

let transactionCountInv (self:multisigwalletwithdailylimit_cel_address) (bst:bstate{self `multisigwalletwithdailylimit_cel_live` bst}) : Type0 =
  let multisigwalletwithdailylimit_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    (forall (i:uint). (((i < cs.multisigwalletwithdailylimit_cel_transactionCount) ==> ((M.contains cs.multisigwalletwithdailylimit_cel_transactions i)))))


let confirmationCountsInv (self:multisigwalletwithdailylimit_cel_address) (bst:bstate{self `multisigwalletwithdailylimit_cel_live` bst}) : Type0 =
  let multisigwalletwithdailylimit_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    (forall (i:uint). ((((M.contains cs.multisigwalletwithdailylimit_cel_transactions i)) ==> ((M.contains cs.multisigwalletwithdailylimit_cel_confirmationCounts i)))))


let receive (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
  False)
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
()

let multisigwalletwithdailylimit_cel_constructor (self:multisigwalletwithdailylimit_cel_address) (sender:address) (value:uint) (tx:tx) (block:block) (initial_owner:address) (_required:uint) (_dailyLimit:uint)
: Eth1 unit
  (fun bst -> 
    multisigwalletwithdailylimit_cel_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_transactions == M.const ({multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }))
      /\ (cs.multisigwalletwithdailylimit_cel_confirmationCounts == M.const (0))
      /\ (cs.multisigwalletwithdailylimit_cel_confirmations == M.const (M.const (false)))
      /\ (cs.multisigwalletwithdailylimit_cel_isOwner == M.const (false))
      /\ (cs.multisigwalletwithdailylimit_cel_ownerCount == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_required == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_transactionCount == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_walletActive == false)
      /\ (cs.multisigwalletwithdailylimit_cel_tx_isConfirmed == false)
      /\ (cs.multisigwalletwithdailylimit_cel_tx_isUnderLimit == false)
      /\ (cs.multisigwalletwithdailylimit_cel_dailyLimit == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_lastDay == 0)
      /\ (cs.multisigwalletwithdailylimit_cel_spentToday == 0)
      /\ (((initial_owner =!= null) /\ (_required > 0)))
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1
    /\ (walletActiveInv self bst1)
    /\ (ownerCountInv self bst1)
    /\ (transactionCountInv self bst1)
    /\ (confirmationCountsInv self bst1)
  )
=
let cs = get_contract self in
let balance = get_balance self in
let isOwner = cs.multisigwalletwithdailylimit_cel_isOwner in
let _ = multisigwalletwithdailylimit_cel_set_isOwner self (M.upd isOwner initial_owner true) in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_ownerCount self 1 in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_required self _required in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_MAX_OWNER_COUNT self 50 in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_dailyLimit self _dailyLimit in
let cs = get_contract self in
()

let addOwnerReverts (_owner:address) (old_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (old_ownerCt:uint) (old_MAX_OWNER_COUNT:uint)
= (((M.sel old_isOwner _owner) \/ (_owner == null)) \/ (((old_ownerCt + 1)) > uint_max)) \/ (((old_ownerCt + 1)) > old_MAX_OWNER_COUNT)

let addOwnerPost (old_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (new_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (old_ownerCount:uint) (new_ownerCount:uint) (_required:uint) (old_walletActive:bool) (new_walletActive:bool) (_owner:address)
= ((M.equal new_isOwner (
                  let x1 = (old_isOwner) in
                  let x2 = (_owner) in
                  let x3 = (true) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1)) /\ (new_ownerCount == (old_ownerCount + 1))) /\ (if (new_ownerCount >= _required) then
  (new_walletActive == true)
else
 (new_walletActive == old_walletActive)
)

let addOwner (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (owner:address)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((addOwnerReverts owner cs.multisigwalletwithdailylimit_cel_isOwner cs.multisigwalletwithdailylimit_cel_ownerCount cs.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ ((addOwnerPost cs0.multisigwalletwithdailylimit_cel_isOwner cs1.multisigwalletwithdailylimit_cel_isOwner cs0.multisigwalletwithdailylimit_cel_ownerCount cs1.multisigwalletwithdailylimit_cel_ownerCount cs0.multisigwalletwithdailylimit_cel_required cs0.multisigwalletwithdailylimit_cel_walletActive cs1.multisigwalletwithdailylimit_cel_walletActive owner))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let target_ownerCount:uint = ((if cs.multisigwalletwithdailylimit_cel_ownerCount <= uint_max - 1 then (cs.multisigwalletwithdailylimit_cel_ownerCount + 1) else revert "Overflow error")) in
let x1 = (((M.sel cs.multisigwalletwithdailylimit_cel_isOwner owner) || (owner = null)) || (target_ownerCount > cs.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)) in
let _ = (if x1 then begin
revert "Invalid owner addition";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let isOwner = cs.multisigwalletwithdailylimit_cel_isOwner in
let _ = multisigwalletwithdailylimit_cel_set_isOwner self (M.upd isOwner owner true) in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_ownerCount self (_add cs.multisigwalletwithdailylimit_cel_ownerCount 1) in
let cs = get_contract self in
let x1 = (cs.multisigwalletwithdailylimit_cel_ownerCount >= cs.multisigwalletwithdailylimit_cel_required) in
let _ = (if x1 then begin
let _ = multisigwalletwithdailylimit_cel_set_walletActive self true in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit multisigwalletwithdailylimit_cel_OwnerAddition owner in
let cs = get_contract self in
let balance = get_balance self in
()

let removeOwnerPost (_owner:address) (old_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (new_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (old_ownerCount:uint) (new_ownerCount:uint) (old_required:uint) (old_walletActive:bool) (new_walletActive:bool)
= ((M.equal new_isOwner (
                  let x1 = (old_isOwner) in
                  let x2 = (_owner) in
                  let x3 = (false) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1)) /\ (new_ownerCount == (old_ownerCount - 1))) /\ (if (new_ownerCount < old_required) then
  (new_walletActive == false)
else
 (new_walletActive == old_walletActive)
)

let removeOwner (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (owner:address)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((~ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner owner))) \/ ((cs.multisigwalletwithdailylimit_cel_ownerCount == 0)))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ ((removeOwnerPost owner cs0.multisigwalletwithdailylimit_cel_isOwner cs1.multisigwalletwithdailylimit_cel_isOwner cs0.multisigwalletwithdailylimit_cel_ownerCount cs1.multisigwalletwithdailylimit_cel_ownerCount cs0.multisigwalletwithdailylimit_cel_required cs0.multisigwalletwithdailylimit_cel_walletActive cs1.multisigwalletwithdailylimit_cel_walletActive))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (op_Negation (M.sel cs.multisigwalletwithdailylimit_cel_isOwner owner)) then begin
revert "Invalid owner removal";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if 1 <= cs.multisigwalletwithdailylimit_cel_ownerCount then (cs.multisigwalletwithdailylimit_cel_ownerCount - 1) else revert "Underflow error")) in
let _ = multisigwalletwithdailylimit_cel_set_ownerCount self x1 in
let cs = get_contract self in
let isOwner = cs.multisigwalletwithdailylimit_cel_isOwner in
let _ = multisigwalletwithdailylimit_cel_set_isOwner self (M.upd isOwner owner false) in
let cs = get_contract self in
let _ = (if (cs.multisigwalletwithdailylimit_cel_ownerCount < cs.multisigwalletwithdailylimit_cel_required) then begin
let _ = multisigwalletwithdailylimit_cel_set_walletActive self false in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit multisigwalletwithdailylimit_cel_OwnerRemoval owner in
let cs = get_contract self in
let balance = get_balance self in
()

let replaceOwnerPost (old_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (new_isOwner:(m:(M.t address bool lt){M.def_of m == false})) (_owner:address) (newOwner:address)
= M.equal new_isOwner (
              let x1 = (old_isOwner) in
              let x2 = (_owner) in
              let x3 = (false) in
              let x1 = (M.upd x1 x2 x3) in
              let x2 = (newOwner) in
              let x3 = (true) in
              let x1 = (M.upd x1 x2 x3) in
              x1)

let replaceOwner (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (owner:address) (newOwner:address)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((~ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner owner)) \/ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner newOwner)))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ ((replaceOwnerPost cs0.multisigwalletwithdailylimit_cel_isOwner cs1.multisigwalletwithdailylimit_cel_isOwner owner newOwner))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((op_Negation (M.sel cs.multisigwalletwithdailylimit_cel_isOwner owner)) || (M.sel cs.multisigwalletwithdailylimit_cel_isOwner newOwner)) then begin
revert "Invalid owner replacement";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let isOwner = cs.multisigwalletwithdailylimit_cel_isOwner in
let _ = multisigwalletwithdailylimit_cel_set_isOwner self (M.upd isOwner owner false) in
let cs = get_contract self in
let isOwner = cs.multisigwalletwithdailylimit_cel_isOwner in
let _ = multisigwalletwithdailylimit_cel_set_isOwner self (M.upd isOwner newOwner true) in
let cs = get_contract self in
let _ = emit multisigwalletwithdailylimit_cel_OwnerRemoval owner in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit multisigwalletwithdailylimit_cel_OwnerAddition newOwner in
let cs = get_contract self in
let balance = get_balance self in
()

let changeRequirementsPost (new_required:uint) (old_ownerCount:uint) (old_walletActive:bool) (new_walletActive:bool)
= if (new_required > old_ownerCount) then
  (new_walletActive == false)
else
 (new_walletActive == old_walletActive)


let changeRequirement (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_required:uint)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ ((changeRequirementsPost cs1.multisigwalletwithdailylimit_cel_required cs0.multisigwalletwithdailylimit_cel_ownerCount cs0.multisigwalletwithdailylimit_cel_walletActive cs1.multisigwalletwithdailylimit_cel_walletActive))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = multisigwalletwithdailylimit_cel_set_required self _required in
let cs = get_contract self in
let _ = (if (cs.multisigwalletwithdailylimit_cel_required > cs.multisigwalletwithdailylimit_cel_ownerCount) then begin
let _ = multisigwalletwithdailylimit_cel_set_walletActive self false in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit multisigwalletwithdailylimit_cel_RequirementChange _required in
let cs = get_contract self in
let balance = get_balance self in
()

let addTransactionPost (old_transactions:(m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }})) (new_transactions:(m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }})) (_txId:uint) (_destination:address) (_val:uint) (old_confirmationCounts:(m:(M.t uint uint lt){M.def_of m == 0})) (new_confirmationCounts:(m:(M.t uint uint lt){M.def_of m == 0})) (old_transactionCount:uint)
= ((M.equal new_transactions (
                  let x1 = (old_transactions) in
                  let x2 = (_txId) in
                  let x3 = ({ multisigwalletwithdailylimit_cel_destination = _destination; multisigwalletwithdailylimit_cel_tval = _val; multisigwalletwithdailylimit_cel_executed = false; }) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1)) /\ (M.equal new_confirmationCounts (
                  let x1 = (old_confirmationCounts) in
                  let x2 = (_txId) in
                  let x3 = (0) in
                  let x1 = (M.upd x1 x2 x3) in
                  x1))) /\ (_txId == old_transactionCount)

let addTransaction (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_destination:address) (_val:uint)
: Eth1 uint
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      ((_destination =!= null))
  ))
  (fun bst -> False)
  (fun bst0 transactionId bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((addTransactionPost cs0.multisigwalletwithdailylimit_cel_transactions cs1.multisigwalletwithdailylimit_cel_transactions transactionId _destination _val cs0.multisigwalletwithdailylimit_cel_confirmationCounts cs1.multisigwalletwithdailylimit_cel_confirmationCounts cs0.multisigwalletwithdailylimit_cel_transactionCount))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let transactionId:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
let transactionId = cs.multisigwalletwithdailylimit_cel_transactionCount in
let cs = get_contract self in
let x1 = ({ multisigwalletwithdailylimit_cel_destination = _destination; multisigwalletwithdailylimit_cel_tval = _val; multisigwalletwithdailylimit_cel_executed = false; }) in
let transactions = cs.multisigwalletwithdailylimit_cel_transactions in
let _ = multisigwalletwithdailylimit_cel_set_transactions self (M.upd transactions transactionId x1) in
let cs = get_contract self in
let confirmationCounts = cs.multisigwalletwithdailylimit_cel_confirmationCounts in
let _ = multisigwalletwithdailylimit_cel_set_confirmationCounts self (M.upd confirmationCounts transactionId 0) in
let cs = get_contract self in
let _ = emit multisigwalletwithdailylimit_cel_Submission transactionId in
let cs = get_contract self in
let balance = get_balance self in
transactionId

let isConfirmedPost (old_confirmationCounts:(m:(M.t uint uint lt){M.def_of m == 0})) (_transactionId:uint) (old_required:uint) (_ret:bool)
= (((_ret == true <==> (M.sel old_confirmationCounts _transactionId) == old_required))) /\ (((_ret == false <==> (M.sel old_confirmationCounts _transactionId) =!= old_required)))

let isConfirmed (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (transactionId:uint)
: Eth1 bool
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst
  )
  (fun bst -> False)
  (fun bst0 ret bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((isConfirmedPost cs0.multisigwalletwithdailylimit_cel_confirmationCounts transactionId cs0.multisigwalletwithdailylimit_cel_required ret))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let ret:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) = cs.multisigwalletwithdailylimit_cel_required) in
let ret = (if x1 then begin
let ret = true in
let cs = get_contract self in
ret end
else begin
let ret = false in
let cs = get_contract self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret

let isUnderLimitPost (time:uint) (old_lastDay:uint) (new_lastDay:uint) (old_spentToday:uint) (new_spentToday:uint) (_amount:uint) (old_dailyLimit:uint) (_ret:bool)
= (if (time > (old_lastDay + 86400)) then
  ((new_lastDay == time) /\ (new_spentToday == 0))
else
 ((new_lastDay == old_lastDay) /\ (new_spentToday == old_spentToday))
) /\ (if (((new_spentToday + _amount) > old_dailyLimit) || ((new_spentToday + _amount) > uint_max)) then
  (_ret == false)
else
 (_ret == true)
)

let isUnderLimit (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_amount:uint)
: Eth1 bool
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst
  )
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.multisigwalletwithdailylimit_cel_lastDay + 86400) > uint_max))
  )
  (fun bst0 ret bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((isUnderLimitPost block.timestamp cs0.multisigwalletwithdailylimit_cel_lastDay cs1.multisigwalletwithdailylimit_cel_lastDay cs0.multisigwalletwithdailylimit_cel_spentToday cs1.multisigwalletwithdailylimit_cel_spentToday _amount cs0.multisigwalletwithdailylimit_cel_dailyLimit ret))
      /\ (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let ret:bool = false in
let cs = get_contract self in
let balance = get_balance self in
let t:uint = ((if cs.multisigwalletwithdailylimit_cel_lastDay <= uint_max - 86400 then (cs.multisigwalletwithdailylimit_cel_lastDay + 86400) else revert "Overflow error")) in
let ret = (if (block.timestamp > t) then begin
let _ = multisigwalletwithdailylimit_cel_set_lastDay self block.timestamp in
let cs = get_contract self in
let _ = multisigwalletwithdailylimit_cel_set_spentToday self 0 in
let cs = get_contract self in
ret end
else ret) in
let cs = get_contract self in
let balance = get_balance self in
let ret = (if (_amount > ((_sub uint_max cs.multisigwalletwithdailylimit_cel_spentToday))) then begin
let ret = false in
let cs = get_contract self in
ret end
else begin
let ret = (if (op_Negation (ret)) then begin
let ret = (if (((_add cs.multisigwalletwithdailylimit_cel_spentToday _amount)) > cs.multisigwalletwithdailylimit_cel_dailyLimit) then begin
let ret = false in
let cs = get_contract self in
ret end
else begin
let ret = true in
let cs = get_contract self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret end
else ret) in
let cs = get_contract self in
let balance = get_balance self in
ret end) in
let cs = get_contract self in
let balance = get_contract self in
ret

let executeTransactionReverts (_transactionId:uint) (old_transactionCount:uint) (old_transactions:(m:(M.t uint multisigwalletwithdailylimit_cel_Transaction lt){M.def_of m == {multisigwalletwithdailylimit_cel_destination = null; multisigwalletwithdailylimit_cel_tval = 0; multisigwalletwithdailylimit_cel_executed = false; }})) (old_balance:uint)
= ((_transactionId >= old_transactionCount) \/ ((M.sel old_transactions _transactionId).multisigwalletwithdailylimit_cel_executed)) \/ (old_balance < ((M.sel old_transactions _transactionId).multisigwalletwithdailylimit_cel_tval))

let executeTransaction (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (transactionId:uint)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((((cs.multisigwalletwithdailylimit_cel_lastDay + 86400) > uint_max)) \/ ((executeTransactionReverts transactionId cs.multisigwalletwithdailylimit_cel_transactionCount cs.multisigwalletwithdailylimit_cel_transactions b)))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ ((if ((M.sel cs0.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) = cs0.multisigwalletwithdailylimit_cel_required) then
  (cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed == true)
else
 (cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed == false)
) /\ ((if (cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed || cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit) then
  (((l1 == ((mk_event null multisigwalletwithdailylimit_cel_Execution transactionId)::(mk_event ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_destination) eTransfer ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval))::l0))) /\ ((M.equal cs1.multisigwalletwithdailylimit_cel_transactions (
                              let x1 = (cs0.multisigwalletwithdailylimit_cel_transactions) in
                              let x2 = (transactionId) in
                              let x3 = ({ multisigwalletwithdailylimit_cel_destination = ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_destination); multisigwalletwithdailylimit_cel_tval = ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval); multisigwalletwithdailylimit_cel_executed = true; }) in
                              let x1 = (M.upd x1 x2 x3) in
                              x1))))
else
 ((l1 == l0) /\ (M.equal cs1.multisigwalletwithdailylimit_cel_transactions cs0.multisigwalletwithdailylimit_cel_transactions))
)))
      /\ (b1 <= b0)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = (((transactionId >= cs.multisigwalletwithdailylimit_cel_transactionCount) || ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_executed)) || (balance < ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval))) in
let _ = (if x1 then begin
revert "invalid";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let trx:multisigwalletwithdailylimit_cel_Transaction = (M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId) in
let x1 = ((isConfirmed self self 0 tx block transactionId)) in
let _ = multisigwalletwithdailylimit_cel_set_tx_isConfirmed self x1 in
let cs = get_contract self in
let x1 = ((isUnderLimit self self 0 tx block trx.multisigwalletwithdailylimit_cel_tval)) in
let _ = multisigwalletwithdailylimit_cel_set_tx_isUnderLimit self x1 in
let cs = get_contract self in
let _ = (if (cs.multisigwalletwithdailylimit_cel_tx_isConfirmed || cs.multisigwalletwithdailylimit_cel_tx_isUnderLimit) then begin
let _ = (if (op_Negation (cs.multisigwalletwithdailylimit_cel_tx_isConfirmed)) then begin
let _ = multisigwalletwithdailylimit_cel_set_spentToday self (_add cs.multisigwalletwithdailylimit_cel_spentToday trx.multisigwalletwithdailylimit_cel_tval) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = true in
let x2 = cs.multisigwalletwithdailylimit_cel_transactions in
let x3 = transactionId in
let x4 = M.sel x2 x3 in
let x5 = M.upd x2 x3 ({x4 with multisigwalletwithdailylimit_cel_executed = x1}) in
let _ = multisigwalletwithdailylimit_cel_set_transactions self x5 in
let cs = get_contract self in
let _ = transfer self ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_destination) trx.multisigwalletwithdailylimit_cel_tval in
let cs = get_contract self in
let balance = get_balance self in
let _ = emit multisigwalletwithdailylimit_cel_Execution transactionId in
let cs = get_contract self in
let balance = get_balance self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
()

let confirmTransaction (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (transactionId:uint)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((((((((~ (cs.multisigwalletwithdailylimit_cel_walletActive)) \/ (~ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender))) \/ (transactionId >= cs.multisigwalletwithdailylimit_cel_transactionCount)) \/ (M.sel (M.sel cs.multisigwalletwithdailylimit_cel_confirmations transactionId) sender)) \/ (((M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) + 1) > uint_max)) \/ (b < ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval))) \/ ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_executed)) \/ ((cs.multisigwalletwithdailylimit_cel_lastDay + 86400) > uint_max)))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ (((M.equal cs1.multisigwalletwithdailylimit_cel_confirmationCounts (
                                                let x1 = (cs0.multisigwalletwithdailylimit_cel_confirmationCounts) in
                                                let x2 = (transactionId) in
                                                let x3 = ((M.sel cs0.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) + 1) in
                                                let x1 = (M.upd x1 x2 x3) in
                                                x1)) /\ (M.equal cs1.multisigwalletwithdailylimit_cel_confirmations (
                                                let x1 = (cs0.multisigwalletwithdailylimit_cel_confirmations) in
                                                let x2 = (transactionId) in
                                                let x3 = (
                                                  let x1 = (M.sel cs0.multisigwalletwithdailylimit_cel_confirmations transactionId) in
                                                  let x2 = (sender) in
                                                  let x3 = (true) in
                                                  let x1 = (M.upd x1 x2 x3) in
                                                  x1) in
                                                let x1 = (M.upd x1 x2 x3) in
                                                x1))) /\ (if (((M.sel cs1.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) = cs0.multisigwalletwithdailylimit_cel_required) || cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit) then
  ((l1 == ((mk_event null multisigwalletwithdailylimit_cel_Execution transactionId)::(mk_event ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_destination) eTransfer ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval))::(mk_event null multisigwalletwithdailylimit_cel_Confirmation (sender, transactionId))::l0)) /\ (M.equal cs1.multisigwalletwithdailylimit_cel_transactions (
                                                        let x1 = (cs0.multisigwalletwithdailylimit_cel_transactions) in
                                                        let x2 = (transactionId) in
                                                        let x3 = ({ multisigwalletwithdailylimit_cel_destination = ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_destination); multisigwalletwithdailylimit_cel_tval = ((M.sel cs0.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_tval); multisigwalletwithdailylimit_cel_executed = true; }) in
                                                        let x1 = (M.upd x1 x2 x3) in
                                                        x1)))
else
 (M.equal cs1.multisigwalletwithdailylimit_cel_transactions cs0.multisigwalletwithdailylimit_cel_transactions)
))
      /\ (b1 <= b0)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((((op_Negation (cs.multisigwalletwithdailylimit_cel_walletActive)) || (op_Negation (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender))) || (transactionId >= cs.multisigwalletwithdailylimit_cel_transactionCount)) || (M.sel (M.sel cs.multisigwalletwithdailylimit_cel_confirmations transactionId) sender)) in
let _ = (if x1 then begin
revert "invalid";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((if (M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) <= uint_max - 1 then ((M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) + 1) else revert "Overflow error")) in
let confirmationCounts = cs.multisigwalletwithdailylimit_cel_confirmationCounts in
let _ = multisigwalletwithdailylimit_cel_set_confirmationCounts self (M.upd confirmationCounts transactionId x1) in
let cs = get_contract self in
let x5 = (true) in
let x4 = cs.multisigwalletwithdailylimit_cel_confirmations in

let x3 = (transactionId) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
                                                  
let _ = multisigwalletwithdailylimit_cel_set_confirmations self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let _ = emit multisigwalletwithdailylimit_cel_Confirmation (sender, transactionId) in
let cs = get_contract self in
let balance = get_balance self in
let _ = (executeTransaction self self 0 tx block transactionId) in
let cs = get_contract self in
()

let submitTransaction (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_dest:address) (_amount:uint)
: Eth1 uint
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((((~ (cs.multisigwalletwithdailylimit_cel_walletActive)) \/ (~ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender))) \/ (_dest == null)) \/ ((cs.multisigwalletwithdailylimit_cel_transactionCount + 1) > uint_max)))
  )
  (fun bst0 transactionId bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1
     /\ (walletActiveInv self bst1)
     /\ (ownerCountInv self bst1)
     /\ (transactionCountInv self bst1)
     /\ (confirmationCountsInv self bst1)
  )
=
let transactionId:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
let x1 = (((op_Negation (cs.multisigwalletwithdailylimit_cel_walletActive)) || (op_Negation (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender))) || (_dest = null)) in
let transactionId = (if x1 then begin
revert "invalid";
transactionId end
else transactionId) in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((addTransaction self self 0 tx block _dest _amount)) in
let transactionId = x1 in
let cs = get_contract self in
let x1 = ((if cs.multisigwalletwithdailylimit_cel_transactionCount <= uint_max - 1 then (cs.multisigwalletwithdailylimit_cel_transactionCount + 1) else revert "Overflow error")) in
let _ = multisigwalletwithdailylimit_cel_set_transactionCount self x1 in
let cs = get_contract self in
transactionId

let revokeConfirmation (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (transactionId:uint)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
      /\ (((M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) > 0))
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((((~ (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender)) \/ (~ (M.sel (M.sel cs.multisigwalletwithdailylimit_cel_confirmations transactionId) sender))) \/ (transactionId > cs.multisigwalletwithdailylimit_cel_transactionCount)) \/ ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_executed)))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_dailyLimit == cs1.multisigwalletwithdailylimit_cel_dailyLimit)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = (if ((((op_Negation (M.sel cs.multisigwalletwithdailylimit_cel_isOwner sender)) || (op_Negation (M.sel (M.sel cs.multisigwalletwithdailylimit_cel_confirmations transactionId) sender))) || (transactionId > cs.multisigwalletwithdailylimit_cel_transactionCount)) || ((M.sel cs.multisigwalletwithdailylimit_cel_transactions transactionId).multisigwalletwithdailylimit_cel_executed)) then begin
revert "Invalid";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let x5 = (false) in
let x4 = cs.multisigwalletwithdailylimit_cel_confirmations in

let x3 = (transactionId) in
let x2 = (M.sel x4 x3) in
let x1 = (sender) in
let x0 = (M.sel x2 x1) in
                                                      
let _ = multisigwalletwithdailylimit_cel_set_confirmations self (M.upd x4 x3 (M.upd x2 x1 x5)) in
let cs = get_contract self in
let x1 = ((if 1 <= (M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) then ((M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId) - 1) else revert "Underflow error")) in
let confirmationCounts = cs.multisigwalletwithdailylimit_cel_confirmationCounts in
let _ = multisigwalletwithdailylimit_cel_set_confirmationCounts self (M.upd confirmationCounts transactionId x1) in
let cs = get_contract self in
let _ = emit multisigwalletwithdailylimit_cel_Revocation (sender, transactionId) in
let cs = get_contract self in
let balance = get_balance self in
()

let getConfirmationCount (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (transactionId:uint)
: Eth1 uint
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
M.sel cs.multisigwalletwithdailylimit_cel_confirmationCounts transactionId

let changeDailyLimit (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block) (_dailyLimit:uint)
: Eth1 unit
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst -> False)
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.multisigwalletwithdailylimit_cel_required == cs1.multisigwalletwithdailylimit_cel_required)
      /\ (cs0.multisigwalletwithdailylimit_cel_ownerCount == cs1.multisigwalletwithdailylimit_cel_ownerCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactions == cs1.multisigwalletwithdailylimit_cel_transactions)
      /\ (cs0.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT == cs1.multisigwalletwithdailylimit_cel_MAX_OWNER_COUNT)
      /\ (cs0.multisigwalletwithdailylimit_cel_isOwner == cs1.multisigwalletwithdailylimit_cel_isOwner)
      /\ (cs0.multisigwalletwithdailylimit_cel_walletActive == cs1.multisigwalletwithdailylimit_cel_walletActive)
      /\ (cs0.multisigwalletwithdailylimit_cel_spentToday == cs1.multisigwalletwithdailylimit_cel_spentToday)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmations == cs1.multisigwalletwithdailylimit_cel_confirmations)
      /\ (cs0.multisigwalletwithdailylimit_cel_transactionCount == cs1.multisigwalletwithdailylimit_cel_transactionCount)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isConfirmed == cs1.multisigwalletwithdailylimit_cel_tx_isConfirmed)
      /\ (cs0.multisigwalletwithdailylimit_cel_confirmationCounts == cs1.multisigwalletwithdailylimit_cel_confirmationCounts)
      /\ (cs0.multisigwalletwithdailylimit_cel_lastDay == cs1.multisigwalletwithdailylimit_cel_lastDay)
      /\ (cs0.multisigwalletwithdailylimit_cel_tx_isUnderLimit == cs1.multisigwalletwithdailylimit_cel_tx_isUnderLimit)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = multisigwalletwithdailylimit_cel_set_dailyLimit self _dailyLimit in
let cs = get_contract self in
let _ = emit multisigwalletwithdailylimit_cel_DailyLimitChange _dailyLimit in
let cs = get_contract self in
let balance = get_balance self in
()

let calcMaxWithdraw (self:multisigwalletwithdailylimit_cel_address) (sender:address{sender <> null}) (value:uint) (tx:tx) (block:block)
: Eth1 uint
  (fun bst ->
    multisigwalletwithdailylimit_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (walletActiveInv self bst)
      /\ (ownerCountInv self bst)
      /\ (transactionCountInv self bst)
      /\ (confirmationCountsInv self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((cs.multisigwalletwithdailylimit_cel_lastDay + 86400) > uint_max))
  )
  (fun bst0 x bst1 ->
    multisigwalletwithdailylimit_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (walletActiveInv self bst1)
      /\ (ownerCountInv self bst1)
      /\ (transactionCountInv self bst1)
      /\ (confirmationCountsInv self bst1)
      /\ (bst0.balances == bst1.balances)
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let ret:uint = (0) in
let endTime:uint = ((if cs.multisigwalletwithdailylimit_cel_lastDay <= uint_max - 86400 then (cs.multisigwalletwithdailylimit_cel_lastDay + 86400) else revert "Overflow error")) in
let _ = (if (block.timestamp > endTime) then begin
let ret = cs.multisigwalletwithdailylimit_cel_dailyLimit in
let cs = get_contract self in
() end
else begin
let _ = (if (cs.multisigwalletwithdailylimit_cel_dailyLimit < cs.multisigwalletwithdailylimit_cel_spentToday) then begin
let ret = 0 in
let cs = get_contract self in
() end
else begin
let ret = (_sub cs.multisigwalletwithdailylimit_cel_dailyLimit cs.multisigwalletwithdailylimit_cel_spentToday) in
let cs = get_contract self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
() end) in
let cs = get_contract self in
let balance = get_contract self in
ret